<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CORE Note Mapping for Writers</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400..700;1,400..700&family=Lato:wght@400;700&family=Special+Elite&display=swap" rel="stylesheet">
    <style>
        /* --- KEYFRAMES FOR ANIMATIONS --- */
        @keyframes pulseGlow {
            0%,
            100% {
                box-shadow: 0 0 10px 2px var(--color-primary);
                opacity: 0.6;
            }
            50% {
                box-shadow: 0 0 20px 8px var(--color-primary);
                opacity: 0.8;
            }
        }

        /* --- THEME AND FONT DEFINITIONS --- */
        :root {
            /* Font Variables */
            --font-display: 'Lora',
            serif;
            --font-sans: 'Lato',
            sans-serif;
            /* Default Theme: Sepia */
            --color-bg-main: #fbfaf5;
            --color-bg-toolbar: #f1ede7;
            --color-bg-modal: #f8f6f2;
            --color-bg-chunk: #ffffff;
            --color-bg-input: #ffffff;
            --color-text-main: #5c5248;
            --color-text-light: #8a7d70;
            --color-text-heading: #4a4137;
            --color-text-inverted: #ffffff;
            --color-border: #dcd3c9;
            --color-shadow: rgba(74, 65, 55, 0.1);
            --color-grid: #e0d8ce;
            --color-primary: #5a7a99;
            --color-primary-hover: #4b6680;
            --color-secondary: #dcd3c9;
            --color-secondary-hover: #c9bfae;
            --color-danger: #c55a5a;
            --color-danger-hover: #a54b4b;
            --color-donate: #5a9973;
            --color-donate-hover: #4b8061;
            --color-link-chunk: #5a7a99;
            --color-link-arrow: #5a7a99;
            --color-link-active: #5a9973;
            --color-chunk-selected: #5a7a99;
        }

        [data-theme="dark"] {
            --color-bg-main: #1f2328;
            --color-bg-toolbar: #1a1d21;
            --color-bg-modal: #282c32;
            --color-bg-chunk: #2c3137;
            --color-bg-input: #1f2328;
            --color-text-main: #c4c8cc;
            --color-text-light: #818a96;
            --color-text-heading: #e1e5e9;
            --color-text-inverted: #1f2328;
            --color-border: #404852;
            --color-shadow: rgba(0, 0, 0, 0.2);
            --color-grid: #3a414a;
            --color-primary: #5c8cae;
            --color-primary-hover: #72a2c9;
            --color-secondary: #404852;
            --color-secondary-hover: #525c68;
            --color-danger: #d96464;
            --color-danger-hover: #e87878;
            --color-donate: #5cae8c;
            --color-donate-hover: #72c9a2;
            --color-link-chunk: #5c8cae;
            --color-link-arrow: #5c8cae;
            --color-link-active: #5cae8c;
            --color-chunk-selected: #5c8cae;
        }

        [data-theme="ballpoint"] {
            --font-display: 'Lora',
            serif;
            --font-sans: 'Lato',
            sans-serif;
            --color-bg-main: #fdfdfd;
            --color-bg-toolbar: #eef2f7;
            --color-bg-modal: #f8f9fa;
            --color-bg-chunk: #ffffff;
            --color-bg-input: #ffffff;
            --color-text-main: #003366;
            /* Dark Blue Ink */
            --color-text-light: #5a7a99;
            --color-text-heading: #002244;
            --color-text-inverted: #ffffff;
            --color-border: #cdd8e3;
            --color-shadow: rgba(0, 51, 102, 0.1);
            --color-grid: #dce4ed;
            /* Light blue grid lines */
            --color-primary: #0055aa;
            --color-primary-hover: #004488;
            --color-secondary: #eef2f7;
            --color-secondary-hover: #dce4ed;
            --color-danger: #d9534f;
            --color-danger-hover: #c9302c;
            --color-donate: #5cb85c;
            --color-donate-hover: #4cae4c;
            --color-link-chunk: #0055aa;
            --color-link-arrow: #0055aa;
            --color-link-active: #5cb85c;
            --color-chunk-selected: #0055aa;
        }

        [data-theme="typewriter"] {
            --font-display: 'Special Elite',
            monospace;
            --font-sans: 'Special Elite',
            monospace;
            --color-bg-main: #f5f1e8;
            /* Aged paper */
            --color-bg-toolbar: #e8e2d7;
            --color-bg-modal: #f2ede4;
            --color-bg-chunk: #fcf8f0;
            --color-bg-input: #fcf8f0;
            --color-text-main: #333333;
            /* Faded black ink */
            --color-text-light: #777777;
            --color-text-heading: #1a1a1a;
            --color-text-inverted: #ffffff;
            --color-border: #dcd3c9;
            --color-shadow: rgba(51, 51, 51, 0.1);
            --color-grid: #e0d8ce;
            --color-primary: #b33a3a;
            /* Typewriter red */
            --color-primary-hover: #993131;
            --color-secondary: #e8e2d7;
            --color-secondary-hover: #dcd3c9;
            --color-danger: #b33a3a;
            --color-danger-hover: #993131;
            --color-donate: #5a9973;
            --color-donate-hover: #4b8061;
            --color-link-chunk: #666666;
            --color-link-arrow: #666666;
            --color-link-active: #b33a3a;
            --color-chunk-selected: #b33a3a;
        }

        [data-theme="typewriter"] .chunk-content,
        [data-theme="typewriter"] .btn {
            font-family: 'Special Elite',
            monospace;
        }

        [data-theme="poetry"] {
            --font-display: 'Lora',
            serif;
            --font-sans: 'Lato',
            sans-serif;
            --color-bg-main: #fbf9f6;
            /* Warmer off-white */
            --color-bg-toolbar: #f5efea;
            --color-bg-modal: #faf6f1;
            --color-bg-chunk: #ffffff;
            --color-bg-input: #ffffff;
            --color-text-main: #5d534a;
            /* Soft, dark brown */
            --color-text-light: #8c7f76;
            --color-text-heading: #4a4137;
            /* Darker brown */
            --color-text-inverted: #ffffff;
            --color-border: #e4dcd3;
            --color-shadow: rgba(89, 83, 74, 0.1);
            --color-grid: #e9e4de;
            --color-primary: #c89a9a;
            /* Dusty Rose */
            --color-primary-hover: #b48484;
            --color-secondary: #f5efea;
            --color-secondary-hover: #e9e2da;
            --color-danger: #c58c8c;
            --color-danger-hover: #a57474;
            --color-donate: #8a9a8c;
            /* Sage Green */
            --color-donate-hover: #758577;
            --color-link-chunk: #c89a9a;
            --color-link-arrow: #c89a9a;
            --color-link-active: #8a9a8c;
            --color-chunk-selected: #c89a9a;
        }

        /* --- BASE STYLES --- */
        body {
            font-family: var(--font-sans);
            background-color: var(--color-bg-main);
            color: var(--color-text-main);
            overscroll-behavior: none;
            overflow: hidden;
            transition: background-color 0.3s,
            color 0.3s;
        }

        #appContainer {
            width: 100vw;
            height: 100dvh;
            display: flex;
            flex-direction: column;
        }

        /* --- CANVAS & GRID --- */
        #noteCanvasContainer {
            position: relative;
            flex-grow: 1;
            overflow: hidden;
            background-color: var(--color-bg-main);
            cursor: grab;
            touch-action: none;
            background-image: linear-gradient(var(--color-grid) 1px, transparent 1px),
            linear-gradient(to right, var(--color-grid) 1px, transparent 1px);
            background-size: 50px 50px;
            transition: background-color 0.3s;
        }

        #noteCanvasContainer.grid-hidden {
            background-image: none;
        }

        #noteCanvasContainer:focus {
            outline: none;
        }

        #noteCanvasContainer.panning {
            cursor: grabbing;
        }

        #transformContainer {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
        }

        #noteCanvas {
            width: 8000px;
            /* Increased canvas size */
            height: 6000px;
            /* Increased canvas size */
            position: relative;
        }

        /* --- CENTER MARKER --- */
        #centerMarker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            transform: translate(-50%, -50%) scale(calc(1 / var(--scale, 1)));
            pointer-events: none;
            z-index: 0;
            transition: opacity 0.3s;
            will-change: transform;
            border-radius: 50%;
            --color-primary: #FACC15;
            /* Tailwind yellow-400 */
            animation: pulseGlow 4s infinite ease-in-out;
        }

        #centerMarker::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--color-primary);
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M12 2l2.54 7.82h8.21l-6.64 4.82 2.54 7.82L12 17.64l-6.65 4.82 2.54-7.82L1.25 9.82h8.21L12 2z'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M12 2l2.54 7.82h8.21l-6.64 4.82 2.54 7.82L12 17.64l-6.65 4.82 2.54-7.82L1.25 9.82h8.21L12 2z'/%3E%3C/svg%3E");
            -webkit-mask-size: contain;
            mask-size: contain;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            -webkit-mask-position: center;
            mask-position: center;
        }

        #centerMarker.hidden {
            opacity: 0;
        }

        /* --- CHUNK STYLES --- */
        #svgCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .core-chunk {
            position: absolute;
            background-color: var(--color-bg-chunk);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            box-shadow: 0 3px 5px var(--color-shadow),
            0 1px 2px var(--color-shadow);
            min-width: 200px;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            overflow: visible;
            transition: border-color 0.2s,
            outline 0.2s,
            background-color 0.3s,
            border-color 0.3s;
            z-index: 1;
        }

        .core-chunk.selected-chunk {
            border-color: var(--color-chunk-selected);
            border-width: 2px;
        }

        .core-chunk.linking-source-chunk {
            outline: 2px solid var(--color-link-active);
            border-color: var(--color-link-active);
        }

        .chunk-header {
            background-color: var(--color-bg-toolbar);
            padding: 6px 10px;
            font-size: 0.75rem;
            font-weight: 400;
            cursor: move;
            border-bottom: 1px solid var(--color-border);
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            touch-action: none;
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
            color: var(--color-text-light);
            transition: background-color 0.3s,
            border-color 0.3s;
            overflow: hidden;
            /* Add overflow hidden to the parent flex container */
        }

        .chunk-header-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
            /* Allow title to shrink */
        }

        .chunk-header-title .tag {
            font-family: var(--font-display);
            font-style: italic;
            font-weight: 600;
            color: var(--color-text-main);
        }

        .chunk-header-title .shape-symbol,
        .chunk-header-title .color-symbol {
            font-weight: normal;
        }

        .chunk-content {
            flex-grow: 1;
            padding: 12px;
            font-size: 0.95rem;
            line-height: 1.6;
            overflow-y: auto;
            outline: none;
        }

        .resize-handle {
            width: 16px;
            height: 16px;
            position: absolute;
            right: -4px;
            bottom: -4px;
            cursor: se-resize;
            touch-action: none;
            z-index: 10;
        }

        .resize-handle::after {
            content: '';
            position: absolute;
            width: 10px;
            height: 10px;
            right: 2px;
            bottom: 2px;
            border-bottom: 2px solid var(--color-text-light);
            border-right: 2px solid var(--color-text-light);
            opacity: 0.5;
            border-bottom-right-radius: 2px;
        }

        /* --- TOOLBAR, BUTTONS, FORMS --- */
        .toolbar {
            background-color: var(--color-bg-toolbar);
            box-shadow: 0 1px 3px var(--color-shadow);
            transition: background-color 0.3s;
            z-index: 100;
        }

        h2,
        h3,
        h4 {
            font-family: var(--font-display);
            font-weight: 600;
            color: var(--color-text-heading);
        }
        h4 {
           font-size: 1.05rem;
           margin-top: 1.25rem;
           margin-bottom: 0.5rem;
        }

        .btn {
            padding: 8px 14px;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s,
            color 0.2s,
            opacity 0.2s,
            transform 0.1s;
            border: 1px solid transparent;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 0.05em;
        }

        .btn:active:not(:disabled) {
            transform: translateY(1px);
        }

        .btn svg.icon {
            width: 16px;
            height: 16px;
            margin-right: 8px;
        }

        .btn svg.spinner {
            width: 18px;
            height: 18px;
            margin: auto;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: var(--color-text-inverted);
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--color-primary-hover);
        }

        .btn-secondary {
            background-color: var(--color-secondary);
            color: var(--color-text-main);
            border-color: var(--color-border);
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: var(--color-secondary-hover);
        }

        .btn-danger {
            background-color: var(--color-danger);
            color: var(--color-text-inverted);
        }

        .btn-danger:hover:not(:disabled) {
            background-color: var(--color-danger-hover);
        }

        .btn-donate {
            background-color: var(--color-donate);
            color: var(--color-text-inverted);
        }

        .btn-donate:hover:not(:disabled) {
            background-color: var(--color-donate-hover);
        }

        .form-input,
        .form-textarea,
        .form-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            margin-bottom: 12px;
            background-color: var(--color-bg-input);
            color: var(--color-text-main);
            transition: background-color 0.3s,
            border-color 0.3s;
        }

        /* --- MODAL STYLES --- */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .modal-content {
            background-color: var(--color-bg-modal);
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 550px;
            border: 1px solid var(--color-border);
            transition: background-color 0.3s,
            border-color 0.3s;
        }

        #helpModal .modal-content,
        #messageModal .modal-content {
            display: flex;
            flex-direction: column;
            max-height: 80vh;
        }

        #help-scroll-content,
        #messageText {
            max-height: 60vh;
            overflow-y: auto;
            line-height: 1.7;
        }

        #help-scroll-content h3 {
            font-family: var(--font-display);
            font-weight: 700;
            color: var(--color-text-heading);
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        #help-scroll-content p,
        #help-scroll-content ul {
            margin-bottom: 0.75rem;
        }

        #help-scroll-content ul {
            list-style-position: inside;
            padding-left: 1rem;
        }

        #help-scroll-content code {
            background-color: var(--color-bg-toolbar);
            padding: 2px 5px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.85rem;
        }

        .close-button {
            color: var(--color-text-light);
            float: right;
            font-size: 28px;
            font-weight: bold;
            line-height: 1;
        }

        .close-button:hover,
        .close-button:focus {
            color: var(--color-text-main);
            text-decoration: none;
            cursor: pointer;
        }

        /* --- LINKING & SVG STYLES --- */
        .connecting-line {
            stroke: var(--color-link-chunk);
            stroke-width: 2;
            fill: none;
            transition: stroke 0.3s;
        }

        .arrow-head {
            fill: var(--color-link-arrow);
            transition: fill 0.3s;
        }

        body.linking-mode {
            cursor: crosshair;
        }

        body.linking-mode .core-chunk:not(.linking-source-chunk):hover {
            outline: 2px dashed var(--color-chunk-selected);
        }

        .link-chunk-btn.linking-active svg {
            stroke: var(--color-link-active) !important;
        }

        /* --- MISC --- */
        footer {
            background-color: var(--color-bg-toolbar);
            transition: background-color 0.3s;
        }

        .chunk-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px;
            margin-left: 4px;
            line-height: 1;
        }

        .chunk-actions {
            flex-shrink: 0;
            /* Prevent the actions container from shrinking */
            padding-left: 8px;
            /* Ensure space between title and buttons */
        }

        .chunk-action-btn svg {
            stroke: var(--color-text-light);
            width: 14px;
            height: 14px;
        }

        .chunk-action-btn:hover svg {
            stroke: var(--color-text-main);
        }

        .delete-chunk-btn:hover svg {
            stroke: var(--color-danger) !important;
        }

        .ai-chunk-btn:hover svg {
            stroke: #8b5cf6 !important;
        }
    </style>
</head>

<body>
    <div id="appContainer">
        <div class="toolbar p-3 shadow-md flex flex-wrap items-center justify-center sm:justify-between gap-x-4 gap-y-2 print:hidden">
            <div class="flex items-center flex-wrap justify-center gap-2">
                <button id="addChunkBtn" class="btn btn-primary" title="Add Chunk (A)">Add</button>
                <button id="shuffleChunksBtn" class="btn btn-secondary" title="Shuffle Chunks">Shuffle</button>
                <button id="spiralLayoutBtn" class="btn btn-secondary" title="Arrange in Spiral">Spiral</button>
                <button id="clearCanvasBtn" class="btn btn-danger" title="Clear Canvas">Clear</button>
            </div>

            <div class="flex items-center flex-wrap justify-center gap-2">
				<button id="undoDeleteBtn" class="btn btn-secondary" title="Undo Last Delete (Ctrl/Cmd+Z)" disabled>Undo</button>
                <button id="zoomOutBtn" class="btn btn-secondary" title="Zoom Out (-)">-</button>
                <button id="zoomResetBtn" class="btn btn-secondary" title="Reset Zoom (0)">100%</button>
                <button id="centerLastBtn" class="btn btn-secondary" title="Center on Last Added Chunk (C)" disabled>Center</button>
                <button id="zoomInBtn" class="btn btn-secondary" title="Zoom In (+/=)">+</button>
            </div>

            <div class="flex items-center flex-wrap justify-center gap-2">
                <span id="chunkCountDisplay" class="text-sm text-gray-500 mx-2">Chunks: 0</span>
				<button id="summarizeBtn" class="btn btn-secondary" title="Summarize the board with AI">
                    Summarize
                </button>
                <button id="saveBtn" class="btn btn-secondary" title="Save to File (Ctrl/Cmd+S)">Save</button>
                <button id="loadBtn" class="btn btn-secondary" title="Load from File (Ctrl/Cmd+O)">Load</button>
                <div class="relative inline-block text-left">
                    <button id="exportBtn" class="btn btn-secondary" title="Export Options">Export</button>
                    <div id="exportDropdown" class="absolute right-0 mt-2 w-40 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 hidden">
                        <div class="py-1" role="menu">
                            <button id="exportTxtBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">TXT</button>
                            <button id="exportHtmlBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">HTML</button>
                            <button id="exportMdBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">MD</button>
                            <button id="exportOpmlBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">OPML</button>
                        </div>
                    </div>
                </div>
                <button id="settingsBtn" class="btn btn-secondary" title="Settings">Settings</button>
                <button id="helpBtn" class="btn btn-secondary" title="Help (?)">Help</button>
                <button id="donateBtn" class="btn btn-donate" title="Support the Project">Donate</button>
            </div>
        </div>

        <div id="noteCanvasContainer" tabindex="-1">
            <div id="transformContainer">
                <div id="noteCanvas">
                    <svg id="svgCanvas"></svg>
                    <div id="centerMarker" class="hidden"></div>
                </div>
            </div>
        </div>
    </div>

    <footer class="text-center p-2 text-xs text-gray-500 print:hidden">
        &copy; <span id="copyrightYear"></span> Thorsten Becker, <a href="https://www.thorstenbecker.de" target="_blank" class="text-blue-600 hover:underline">thorstenbecker.de</a>.
    </footer>

    <div id="addChunkModal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-xl mb-4">Add New Chunk</h2>
            <label for="chunkTypeSelect" class="block mb-1 font-medium">Chunk Type:</label>
            <select id="chunkTypeSelect" class="form-select"></select>
            <label for="chunkColorSelect" class="block mb-1 mt-3 font-medium">Color Tag:</label>
            <select id="chunkColorSelect" class="form-select"></select>
            <div class="mt-6 flex justify-end gap-2">
                <button id="cancelAddChunkBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmAddChunkBtn" class="btn btn-primary">Add Chunk</button>
            </div>
        </div>
    </div>
    <div id="editChunkModal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-xl mb-4">Edit Chunk</h2>
            <input type="hidden" id="editingChunkId">
            <label for="editChunkTypeSelect" class="block mb-1 font-medium">Chunk Type:</label>
            <select id="editChunkTypeSelect" class="form-select"></select>
            <label for="editChunkColorSelect" class="block mb-1 mt-3 font-medium">Color Tag:</label>
            <select id="editChunkColorSelect" class="form-select"></select>
            <div class="mt-6 flex justify-end gap-2">
                <button id="cancelEditChunkBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmEditChunkBtn" class="btn btn-primary">Save Changes</button>
            </div>
        </div>
    </div>
    <div id="aiActionModal" class="modal hidden">
        <div class="modal-content"> <span id="closeAiActionModalBtn" class="close-button">&times;</span>
            <h2 class="flex items-center text-xl mb-4">AI Assistant</h2>
            <p class="text-sm text-gray-600 mb-4">Powered by Gemini. Current chunk content will be used as context.</p> <label for="aiPromptTextarea" class="block mb-1 mt-3 font-medium">Your Prompt:</label> <textarea id="aiPromptTextarea" class="form-textarea" placeholder="e.g., 'Rewrite this to be more concise.'"></textarea>
            <div class="mt-4 flex flex-wrap justify-between items-center gap-2"> <button id="aiActionSuggestNextBtn" class="btn btn-secondary">Suggest Next</button>
                <div class="flex-grow"></div> <button id="cancelAiActionBtn" class="btn btn-secondary">Cancel</button> <button id="aiActionGenerateBtn" class="btn btn-primary">Generate & Replace</button>
            </div>
        </div>
    </div>
    <div id="messageModal" class="modal hidden">
        <div class="modal-content max-w-lg">
            <h2 id="messageTitle" class="text-xl font-semibold mb-3">Message</h2>
            <div id="messageText" class="mb-4 text-sm"></div>
            <div id="messageButtons" class="flex justify-end gap-3"></div>
        </div>
    </div>

    <div id="settingsModal" class="modal hidden">
        <div class="modal-content">
            <span id="closeSettingsModalBtn" class="close-button">&times;</span>
            <h2 class="text-xl mb-6">Settings</h2>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                <div>
                    <label for="themeSelect" class="block mb-2 font-medium">Theme</label>
                    <select id="themeSelect" class="form-select">
                        <option value="sepia">Sepia</option>
                        <option value="dark">Dark</option>
                        <option value="ballpoint">Ballpoint</option>
                        <option value="typewriter">Typewriter</option>
                        <option value="poetry">Poetry</option>
                    </select>
                </div>
                <div class="flex flex-col justify-end">
                    <div class="flex items-center space-x-8">
                        <label for="gridToggle" class="flex items-center cursor-pointer">
                            <input type="checkbox" id="gridToggle" class="form-input h-5 w-5 mr-3">
                            <span class="font-medium">Show Grid</span>
                        </label>
                        <label for="centerMarkerToggle" class="flex items-center cursor-pointer">
                            <input type="checkbox" id="centerMarkerToggle" class="form-input h-5 w-5 mr-3">
                            <span class="font-medium">Show Center Marker</span>
                        </label>
                    </div>
                </div>
            </div>

            <hr class="border-t border-border my-6">

            <label for="geminiApiKeyInput" class="block mb-1 font-medium">Google AI API Key</label>
            <p class="text-xs text-text-light mb-2">Required for AI features. Your key is saved only in your browser.</p>
            <input type="password" id="geminiApiKeyInput" class="form-input" placeholder="Enter your API key here">
            <p class="text-xs text-text-light mb-4">Get a key from <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-[var(--color-primary)] hover:underline">Google AI Studio</a>.</p>

            <div class="mt-6 flex justify-end gap-2">
                <button id="cancelSettingsBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveSettingsBtn" class="btn btn-primary">Save Settings</button>
            </div>
        </div>
    </div>

    <div id="helpModal" class="modal hidden">
        <div class="modal-content">
            <span id="closeHelpModalSpan" class="close-button">&times;</span>
            <h2 class="text-2xl mb-4">CORE Quick Help</h2>
            <div id="help-scroll-content">
            </div>
            <div class="mt-6 flex justify-end"><button id="closeHelpBtn" class="btn btn-primary">OK</button></div>
        </div>
    </div>
    
    <div id="sessionRestoreModal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-xl mb-4">Welcome Back!</h2>
            <p class="mb-6 text-text-main">
                We've restored your last session from a secure, local browser save.
                You can continue where you left off, or start with a fresh, blank canvas.
            </p>
            <div class="flex justify-end gap-3">
                <button id="startFreshBtn" class="btn btn-secondary">Start Fresh</button>
                <button id="continueSessionBtn" class="btn btn-primary">Continue</button>
            </div>
        </div>
    </div>

    <input type="file" id="fileLoadInput" class="hidden" accept=".json,application/json">

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Constants and App Config ---
            const CHUNK_TYPES = {
                core: [{
                    tag: "#central",
                    description: "The seed thought, core concept"
                }, {
                    tag: "#essential",
                    description: "Key supporting points or moments"
                }, {
                    tag: "#expanded",
                    description: "Deeper exploration, examples, nuance"
                }, {
                    tag: "#supportive",
                    description: "Details, quotes, sensory notes"
                }, {
                    tag: "#transition",
                    description: "Bridge between sections or ideas"
                }, {
                    tag: "#loopback",
                    description: "Refers to another chunk, prior note, or core concept"
                }, {
                    tag: "#conclusive",
                    description: "Ending remarks, reflection, resolution"
                }],
                optional: [{
                    tag: "#contextual",
                    description: "Background information, historical context, or literature review content"
                }, {
                    tag: "#counterpoint",
                    description: "Opposing viewpoints, limitations, or challenges to the central idea"
                }, {
                    tag: "#application",
                    description: "Practical implications, 'how-to' elements, or real-world relevance"
                }],
                narrative: [{
                    tag: "#temporal",
                    description: "Indicates a passage of time (e.g., 'Later that evening…')"
                }, {
                    tag: "#spatial",
                    description: "Marks a location change (e.g., 'Across the city…')"
                }, {
                    tag: "#spatiotemporal",
                    description: "Combines time and location shift (e.g., 'Meanwhile, in Tokyo…')"
                }, {
                    tag: "#flashback",
                    description: "Indicates a past event or memory outside the main timeline"
                }],
                conceptual: [{
                    tag: "#dreamlike",
                    description: "Marks dream sequences, hallucinations, or altered states"
                }, {
                    tag: "#perspective",
                    description: "Indicates a shift in point of view or narrative lens"
                }]
            };
            const ALL_CHUNK_TYPES = Object.values(CHUNK_TYPES).flat();
            const SHAPE_MAP = {
                "#central": { name: "Circle", symbol: "◯", meaning: "The seed thought, core concept" },
                "#essential": { name: "Square", symbol: "▢", meaning: "Key supporting points or moments" },
                "#expanded": { name: "Diamond", symbol: "◇", meaning: "Deeper exploration, examples, nuance" },
                "#supportive": { name: "Panel", symbol: "▱", meaning: "Details, quotes, sensory notes" },
                "#transition": { name: "(Hook) Arrow", symbol: "⤣", meaning: "Bridge between sections or ideas" },
                "#loopback": { name: "Loop", symbol: "↺", meaning: "Refers to another chunk, prior note, or core concept" },
                "#conclusive": { name: "Equals", symbol: "=", meaning: "Ending remarks, reflection, resolution" },
                "#contextual": { name: "Info", symbol: "ⓘ", meaning: "Background or literature review" },
                "#counterpoint": { name: "Not equal", symbol: "≠", meaning: "Opposing viewpoints or challenges" },
                "#application": { name: "Forward arrow", symbol: "⇢", meaning: "Real-world relevance, how-to steps" },
                "#temporal": { name: "Time dial", symbol: "◷", meaning: "Passage of time" },
                "#spatial": { name: "Location pin", symbol: "⌖", meaning: "Location change" },
                "#spatiotemporal": { name: "Combine", symbol: "◷+⌖", meaning: "Combined time and place shift" },
                "#flashback": { name: "Back arrow", symbol: "↶", meaning: "Memory or past event" },
                "#dreamlike": { name: "Tilde", symbol: "~", meaning: "Altered states, hallucinations, surreal elements" },
                "#perspective": { name: "Half circle", symbol: "◐", meaning: "Change in narrative lens or point of view" }
            };
            const COLORS = [
                { name: "Green", symbol: "🟢", essence: "grounded, stable", tailwindClass: "text-green-500" },
                { name: "Yellow", symbol: "🟡", essence: "curious, exploratory", tailwindClass: "text-yellow-400" },
                { name: "Blue", symbol: "🔵", essence: "calm, reflective", tailwindClass: "text-blue-500" },
                { name: "Purple", symbol: "🟣", essence: "deep, contemplative", tailwindClass: "text-purple-500" },
                { name: "Red", symbol: "🔴", essence: "Urgency, conflict", tailwindClass: "text-red-500" },
                { name: "Grey", symbol: "🔘", essence: "fog, uncertainty", tailwindClass: "text-gray-500" }
            ];
            const ICON_PENCIL_EDIT = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" /></svg>`;
            const ICON_LINK = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" /></svg>`;
            const ICON_UNLINK = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244m-9.951-2.206a4.5 4.5 0 006.364-6.364L9.65 3.65m-3.069 3.069L3.5 9.787m0 0L1.454 7.742M3.5 9.787l2.046 2.046M3 3l18 18" /></svg>`;
            const ICON_LINKING_ACTIVE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="animate-pulse"><path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" /></svg>`;
            const ICON_DELETE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" /></svg>`;
            const ICON_AI_SPARKLE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.25 10.5l-1.5-1.5 1.5-1.5 1.5 1.5-1.5 1.5ZM16.5 3.75l-1.5-1.5 1.5-1.5 1.5 1.5-1.5 1.5Z" /></svg>`;
            const MIN_SCALE = 0.1,
                MAX_SCALE = 3.0,
                ZOOM_SENSITIVITY = 0.001;
            const GRID_SIZE = 50;

            // --- DOM Elements Cache ---
            const DOMElements = {
                body: document.body,
                noteCanvasContainer: document.getElementById('noteCanvasContainer'),
                transformContainer: document.getElementById('transformContainer'),
                svgCanvas: document.getElementById('svgCanvas'),
                noteCanvas: document.getElementById('noteCanvas'),
                centerMarker: document.getElementById('centerMarker'),
                // Toolbar
                addChunkBtn: document.getElementById('addChunkBtn'),
                centerLastBtn: document.getElementById('centerLastBtn'),
                shuffleChunksBtn: document.getElementById('shuffleChunksBtn'),
                spiralLayoutBtn: document.getElementById('spiralLayoutBtn'),
                clearCanvasBtn: document.getElementById('clearCanvasBtn'),
                undoDeleteBtn: document.getElementById('undoDeleteBtn'),
                chunkCountDisplay: document.getElementById('chunkCountDisplay'),
                zoomInBtn: document.getElementById('zoomInBtn'),
                zoomOutBtn: document.getElementById('zoomOutBtn'),
                zoomResetBtn: document.getElementById('zoomResetBtn'),
                // Modals
                addChunkModal: document.getElementById('addChunkModal'),
                chunkTypeSelect: document.getElementById('chunkTypeSelect'),
                chunkColorSelect: document.getElementById('chunkColorSelect'),
                confirmAddChunkBtn: document.getElementById('confirmAddChunkBtn'),
                cancelAddChunkBtn: document.getElementById('cancelAddChunkBtn'),
                editChunkModal: document.getElementById('editChunkModal'),
                editingChunkIdInput: document.getElementById('editingChunkId'),
                editChunkTypeSelect: document.getElementById('editChunkTypeSelect'),
                editChunkColorSelect: document.getElementById('editChunkColorSelect'),
                confirmEditChunkBtn: document.getElementById('confirmEditChunkBtn'),
                cancelEditChunkBtn: document.getElementById('cancelEditChunkBtn'),
                summarizeBtn: document.getElementById('summarizeBtn'),
                // Settings & Help
                settingsBtn: document.getElementById('settingsBtn'),
                settingsModal: document.getElementById('settingsModal'),
                geminiApiKeyInput: document.getElementById('geminiApiKeyInput'),
                saveSettingsBtn: document.getElementById('saveSettingsBtn'),
                cancelSettingsBtn: document.getElementById('cancelSettingsBtn'),
                closeSettingsModalBtn: document.getElementById('closeSettingsModalBtn'),
                themeSelect: document.getElementById('themeSelect'),
                gridToggle: document.getElementById('gridToggle'),
                centerMarkerToggle: document.getElementById('centerMarkerToggle'),
                donateBtn: document.getElementById('donateBtn'),
                helpBtn: document.getElementById('helpBtn'),
                helpModal: document.getElementById('helpModal'),
                helpContent: document.getElementById('help-scroll-content'),
                closeHelpBtn: document.getElementById('closeHelpBtn'),
                closeHelpModalSpan: document.getElementById('closeHelpModalSpan'),
                // AI
                aiActionModal: document.getElementById('aiActionModal'),
                aiPromptTextarea: document.getElementById('aiPromptTextarea'),
                aiActionGenerateBtn: document.getElementById('aiActionGenerateBtn'),
                aiActionSuggestNextBtn: document.getElementById('aiActionSuggestNextBtn'),
                cancelAiActionBtn: document.getElementById('cancelAiActionBtn'),
                closeAiActionModalBtn: document.getElementById('closeAiActionModalBtn'),
                // I/O
                saveBtn: document.getElementById('saveBtn'),
                loadBtn: document.getElementById('loadBtn'),
                fileLoadInput: document.getElementById('fileLoadInput'),
                exportBtn: document.getElementById('exportBtn'),
                exportDropdown: document.getElementById('exportDropdown'),
                exportTxtBtn: document.getElementById('exportTxtBtn'),
                exportHtmlBtn: document.getElementById('exportHtmlBtn'),
                exportMdBtn: document.getElementById('exportMdBtn'),
                exportOpmlBtn: document.getElementById('exportOpmlBtn'),
                // Message
                messageModal: document.getElementById('messageModal'),
                messageTitle: document.getElementById('messageTitle'),
                messageText: document.getElementById('messageText'),
                messageButtons: document.getElementById('messageButtons'),
                // Session Restore
                sessionRestoreModal: document.getElementById('sessionRestoreModal'),
                continueSessionBtn: document.getElementById('continueSessionBtn'),
                startFreshBtn: document.getElementById('startFreshBtn'),
            };

            // --- App State ---
            let state = {
                chunks: [],
                chunksMap: new Map(),
                highestZIndex: 1,
                selectedChunkId: null,
                lastDeletedChunk: null,
                lastAddedChunkId: null,
                linkingMode: false,
                linkingSourceChunkId: null,
                geminiApiKey: null,
                activeAiChunkId: null,
                spiralClockwise: false, // For toggling spiral direction
                // Transform state
                scale: 1,
                translateX: 0,
                translateY: 0,
                // Interaction state
                currentAction: null,
                panStartX: 0,
                panStartY: 0,
                interactionStartX: 0,
                interactionStartY: 0,
                offsetX: 0,
                offsetY: 0,
                startWidth: 0,
                startHeight: 0,
                initialPinchDistance: null,
                transformUpdateQueued: false,
            };

            let originalTheme = 'sepia';

            // --- Utility Functions ---
            const generateId = () => 'chunk-' + Date.now() + '-' + Math.random().toString(36).substring(2, 9);
            const showModal = (modal) => modal.classList.remove('hidden');
            const hideModal = (modal) => modal.classList.add('hidden');

            function showMessage(title, text, buttonsConfig = [{
                text: 'OK',
                class: 'btn-primary',
                action: () => hideModal(DOMElements.messageModal)
            }]) {
                DOMElements.messageTitle.textContent = title;
                DOMElements.messageText.innerHTML = text;
                DOMElements.messageButtons.innerHTML = '';
                buttonsConfig.forEach(btnConfig => {
                    const button = document.createElement('button');
                    button.className = `btn ${btnConfig.class || 'btn-secondary'} m-1`;
                    button.textContent = btnConfig.text;
                    button.onclick = () => {
                        if (btnConfig.action) btnConfig.action();
                        if (!btnConfig.noHide) hideModal(DOMElements.messageModal);
                    };
                    DOMElements.messageButtons.appendChild(button);
                });
                showModal(DOMElements.messageModal);
            }

            // --- Auto-Save & Session Management ---
            const AUTO_SAVE_KEY = 'coreAutoSave';
            let autoSaveTimeout;

            function triggerAutoSave() {
                clearTimeout(autoSaveTimeout);
                autoSaveTimeout = setTimeout(() => {
                    if (state.chunks.length === 0) {
                        clearAutoSave();
                    } else {
                        state.chunks.forEach(chunkData => {
                            const chunkElement = document.getElementById(chunkData.id);
                            if (chunkElement) {
                                const contentDiv = chunkElement.querySelector('.chunk-content');
                                if (contentDiv) {
                                    chunkData.text = contentDiv.innerHTML;
                                }
                            }
                        });
                        const dataToSave = {
                            chunks: state.chunks,
                            viewport: {
                                scale: state.scale,
                                translateX: state.translateX,
                                translateY: state.translateY
                            },
                            lastAddedChunkId: state.lastAddedChunkId,
                            highestZIndex: state.highestZIndex,
                            lastDeletedChunk: state.lastDeletedChunk
                        };
                        localStorage.setItem(AUTO_SAVE_KEY, JSON.stringify(dataToSave));
                    }
                }, 1000); 
            }

            function clearAutoSave() {
                localStorage.removeItem(AUTO_SAVE_KEY);
                console.log("Auto-save data cleared.");
            }

            function loadSessionFromAutoSave() {
                const savedDataJSON = localStorage.getItem(AUTO_SAVE_KEY);
                if (savedDataJSON) {
                    try {
                        const savedData = JSON.parse(savedDataJSON);
                        if (savedData && Array.isArray(savedData.chunks) && savedData.chunks.length > 0) {
                            state.chunks = savedData.chunks;
                            if (savedData.viewport) {
                                state.scale = savedData.viewport.scale || 1;
                                state.translateX = savedData.viewport.translateX || 0;
                                state.translateY = savedData.viewport.translateY || 0;
                            }
                            state.lastAddedChunkId = savedData.lastAddedChunkId || null;
                            state.highestZIndex = savedData.highestZIndex || 1;
                            state.lastDeletedChunk = savedData.lastDeletedChunk || null;

                            showModal(DOMElements.sessionRestoreModal);
                            return true; 
                        }
                    } catch (e) {
                        console.error("Error parsing auto-saved session data:", e);
                        clearAutoSave(); 
                    }
                }
                return false; 
            }

            // --- Settings & Preferences ---
            function applyTheme(themeName) {
                DOMElements.body.dataset.theme = themeName;
            }

            function toggleGridVisibility(isVisible) {
                DOMElements.noteCanvasContainer.classList.toggle('grid-hidden', !isVisible);
            }

            function toggleCenterMarkerVisibility(isVisible) {
                DOMElements.centerMarker.classList.toggle('hidden', !isVisible);
            }

            function loadSettings() {
                const key = localStorage.getItem('geminiApiKey');
                if (key) {
                    state.geminiApiKey = key;
                    DOMElements.geminiApiKeyInput.value = key;
                }
                const theme = localStorage.getItem('coreTheme') || 'sepia';
                DOMElements.themeSelect.value = theme;
                applyTheme(theme);
                originalTheme = theme;

                const isGridVisible = localStorage.getItem('coreGridVisible') !== 'false';
                DOMElements.gridToggle.checked = isGridVisible;
                toggleGridVisibility(isGridVisible);

                const isMarkerVisible = localStorage.getItem('coreMarkerVisible') === 'true';
                DOMElements.centerMarkerToggle.checked = isMarkerVisible;
                toggleCenterMarkerVisibility(isMarkerVisible);
            }

            function saveSettings() {
                const key = DOMElements.geminiApiKeyInput.value.trim();
                if (key) {
                    state.geminiApiKey = key;
                    localStorage.setItem('geminiApiKey', key);
                } else {
                    state.geminiApiKey = null;
                    localStorage.removeItem('geminiApiKey');
                }
                const theme = DOMElements.themeSelect.value;
                localStorage.setItem('coreTheme', theme);
                applyTheme(theme);
                originalTheme = theme;

                const isGridVisible = DOMElements.gridToggle.checked;
                localStorage.setItem('coreGridVisible', isGridVisible);
                toggleGridVisibility(isGridVisible);

                const isMarkerVisible = DOMElements.centerMarkerToggle.checked;
                localStorage.setItem('coreMarkerVisible', isMarkerVisible);
                toggleCenterMarkerVisibility(isMarkerVisible);

                showMessage("Settings Saved", "Your preferences have been updated.");
                hideModal(DOMElements.settingsModal);
            }

            function cancelSettings() {
                applyTheme(originalTheme);
                DOMElements.themeSelect.value = originalTheme;
                hideModal(DOMElements.settingsModal);
            }

            // --- Transform and Coordinate Functions ---
            function applyTransform() {
                if (state.transformUpdateQueued) return;
                state.transformUpdateQueued = true;
                requestAnimationFrame(() => {
                    DOMElements.transformContainer.style.transform = `translate(${state.translateX}px, ${state.translateY}px) scale(${state.scale})`;
                    DOMElements.noteCanvasContainer.style.setProperty('--scale', state.scale);
                    const bgPosX = state.translateX % (GRID_SIZE * state.scale);
                    const bgPosY = state.translateY % (GRID_SIZE * state.scale);
                    DOMElements.noteCanvasContainer.style.backgroundPosition = `${bgPosX}px ${bgPosY}px`;
                    DOMElements.noteCanvasContainer.style.backgroundSize = `${GRID_SIZE * state.scale}px ${GRID_SIZE * state.scale}px`;
                    DOMElements.svgCanvas.setAttribute('width', String(DOMElements.noteCanvas.scrollWidth));
                    DOMElements.svgCanvas.setAttribute('height', String(DOMElements.noteCanvas.scrollHeight));
                    drawConnections();
                    state.transformUpdateQueued = false;
                });
            }

            function screenToWorld(screenX, screenY) {
                const containerRect = DOMElements.noteCanvasContainer.getBoundingClientRect();
                const worldX = (screenX - containerRect.left - state.translateX) / state.scale;
                const worldY = (screenY - containerRect.top - state.translateY) / state.scale;
                return {
                    x: worldX,
                    y: worldY
                };
            }

            function centerOnChunk(chunkId) {
                const chunkData = state.chunksMap.get(chunkId);
                if (!chunkData) return;
                const viewportWidth = DOMElements.noteCanvasContainer.clientWidth;
                const viewportHeight = DOMElements.noteCanvasContainer.clientHeight;
                const newScale = 1.0;
                state.scale = newScale;
                const chunkCenterX = chunkData.x + chunkData.width / 2;
                const chunkCenterY = chunkData.y + chunkData.height / 2;
                state.translateX = viewportWidth / 2 - chunkCenterX * newScale;
                state.translateY = viewportHeight / 2 - chunkCenterY * newScale;
                applyTransform();
                triggerAutoSave();
            }


            function resetAndCenterView() {
                state.scale = 1;
                const viewportWidth = DOMElements.noteCanvasContainer.clientWidth;
                const viewportHeight = DOMElements.noteCanvasContainer.clientHeight;
                const canvasContentWidth = DOMElements.noteCanvas.scrollWidth;
                const canvasContentHeight = DOMElements.noteCanvas.scrollHeight;
                state.translateX = (viewportWidth - canvasContentWidth * state.scale) / 2;
                state.translateY = (viewportHeight - canvasContentHeight * state.scale) / 2;
                applyTransform();
                triggerAutoSave();
            }

            // --- Board Rendering ---
            function renderBoard(loadedChunksData) {
                DOMElements.noteCanvas.querySelectorAll('.core-chunk').forEach(el => el.remove());
                DOMElements.svgCanvas.innerHTML = '';
                svgDefsCreated = false;

                state.chunks = loadedChunksData || [];
                state.chunksMap.clear();
                state.highestZIndex = state.highestZIndex || 0;
                state.selectedChunkId = null;
                DOMElements.undoDeleteBtn.disabled = !state.lastDeletedChunk;
                DOMElements.centerLastBtn.disabled = !state.lastAddedChunkId;
                cancelLinkingMode(true);

                if (Array.isArray(state.chunks)) {
                    state.chunks.forEach(chunkData => {
                        if (chunkData && chunkData.id) {
                            state.chunksMap.set(chunkData.id, chunkData);
                            createChunkElement(chunkData);
                            if (chunkData.zIndex > state.highestZIndex) {
                                state.highestZIndex = chunkData.zIndex;
                            }
                        }
                    });
                }
                if (state.chunks.length === 0) {
                    state.highestZIndex = 1;
                    state.lastAddedChunkId = null;
                    DOMElements.centerLastBtn.disabled = true;
                }

                updateSelectedVisuals();
                drawConnections();
                updateChunkCounter();
                triggerAutoSave();
            }

            // --- Chunk Management ---
            function addChunkToCanvas(chunkDetails, options = {}) {
                const viewportRect = DOMElements.noteCanvasContainer.getBoundingClientRect();
                const defaultWorldPos = screenToWorld(viewportRect.left + viewportRect.width / 2, viewportRect.top + viewportRect.height / 4);
                
                const shapeInfo = SHAPE_MAP[chunkDetails.type.tag] || { name: 'Default', symbol: '?', meaning: 'Undefined' };

                const newChunkData = {
                    id: generateId(),
                    chunkTypeTag: chunkDetails.type.tag,
                    shapeName: shapeInfo.name,
                    colorName: chunkDetails.color.name,
                    text: options.text || '<p>New chunk... Start typing!</p>',
                    x: options.x !== undefined ? options.x : Math.max(0, defaultWorldPos.x - 125),
                    y: options.y !== undefined ? options.y : Math.max(0, defaultWorldPos.y - 75),
                    width: 250,
                    height: 150,
                    zIndex: ++state.highestZIndex,
                    nextChunkId: null
                };

                state.chunks.push(newChunkData);
                state.chunksMap.set(newChunkData.id, newChunkData);
                createChunkElement(newChunkData);
                selectChunk(newChunkData.id);
                state.lastAddedChunkId = newChunkData.id;
                DOMElements.centerLastBtn.disabled = false;

                drawConnections();
                updateChunkCounter();
                triggerAutoSave();
                return newChunkData;
            }

            function createChunkElement(chunkData) {
                const chunkDiv = document.createElement('div');
                chunkDiv.id = chunkData.id;
                chunkDiv.className = 'core-chunk';
                chunkDiv.style.left = chunkData.x + 'px';
                chunkDiv.style.top = chunkData.y + 'px';
                chunkDiv.style.width = chunkData.width + 'px';
                chunkDiv.style.height = chunkData.height + 'px';
                chunkDiv.style.zIndex = String(chunkData.zIndex);

                const header = document.createElement('div');
                header.className = 'chunk-header';

                const headerTitle = document.createElement('span');
                headerTitle.className = 'chunk-header-title';

                const actionsContainer = document.createElement('div');
                actionsContainer.className = 'chunk-actions flex items-center';

                const createActionButton = (className, title, icon, handler) => {
                    const btn = document.createElement('button');
                    btn.className = `chunk-action-btn ${className}`;
                    btn.title = title;
                    btn.innerHTML = icon;
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        handler(e);
                    });
                    btn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        handler(e);
                    });
                    return btn;
                };

                const aiBtn = createActionButton('ai-chunk-btn', 'AI Assistant', ICON_AI_SPARKLE, () => openAiModal(chunkData.id));
                const editBtn = createActionButton('edit-chunk-btn', 'Edit Properties', ICON_PENCIL_EDIT, () => openEditChunkModal(chunkData.id));
                const linkBtn = createActionButton('link-chunk-btn', 'Link Chunk', ICON_LINK, () => handleLinkButtonClick(chunkData.id));
                const deleteBtn = createActionButton('delete-chunk-btn', 'Delete Chunk', ICON_DELETE, () => deleteChunk(chunkData.id));

                actionsContainer.appendChild(aiBtn);
                actionsContainer.appendChild(editBtn);
                actionsContainer.appendChild(linkBtn);
                actionsContainer.appendChild(deleteBtn);

                header.appendChild(headerTitle);
                header.appendChild(actionsContainer);

                const content = document.createElement('div');
                content.className = 'chunk-content';
                content.contentEditable = true;
                content.innerHTML = chunkData.text;
                content.addEventListener('input', () => {
                    state.chunksMap.get(chunkDiv.id).text = content.innerHTML;
                    triggerAutoSave();
                });
                content.addEventListener('focus', () => {
                    chunkDiv.style.zIndex = String(++state.highestZIndex);
                    state.chunksMap.get(chunkDiv.id).zIndex = state.highestZIndex;
                    if (!state.linkingMode) selectChunk(chunkData.id);
                });

                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle';

                header.addEventListener('mousedown', onInteractionStart);
                header.addEventListener('touchstart', onInteractionStart, {
                    passive: false
                });
                resizeHandle.addEventListener('mousedown', onInteractionStart);
                resizeHandle.addEventListener('touchstart', onInteractionStart, {
                    passive: false
                });

                chunkDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (state.linkingMode) {
                        if (state.linkingSourceChunkId && state.linkingSourceChunkId !== chunkData.id) {
                            completeLink(state.linkingSourceChunkId, chunkData.id);
                        }
                    } else {
                        selectChunk(chunkData.id);
                    }
                });

                chunkDiv.appendChild(header);
                chunkDiv.appendChild(content);
                chunkDiv.appendChild(resizeHandle);
                DOMElements.noteCanvas.appendChild(chunkDiv);

                updateChunkHeaderDisplay(chunkData.id);
                updateSelectedVisuals();

                return chunkDiv;
            }


            function deleteChunk(chunkIdToDelete) {
                showMessage("Confirm Delete", `Are you sure you want to delete this chunk?`, [{
                    text: 'Cancel',
                    class: 'btn-secondary'
                }, {
                    text: 'Delete',
                    class: 'btn-danger',
                    action: () => {
                        const chunkIndex = state.chunks.findIndex(c => c.id === chunkIdToDelete);
                        if (chunkIndex > -1) {
                            state.lastDeletedChunk = JSON.parse(JSON.stringify(state.chunks[chunkIndex]));
                            state.chunks.splice(chunkIndex, 1);
                            state.chunksMap.delete(chunkIdToDelete);
                            DOMElements.undoDeleteBtn.disabled = false;
                        }
                        if (state.selectedChunkId === chunkIdToDelete) deselectAllChunks();
                        if (state.linkingSourceChunkId === chunkIdToDelete) cancelLinkingMode(false);
                        if (state.lastAddedChunkId === chunkIdToDelete) {
                            state.lastAddedChunkId = null;
                            DOMElements.centerLastBtn.disabled = true;
                        }

                        state.chunks.forEach(chunk => {
                            if (chunk.nextChunkId === chunkIdToDelete) chunk.nextChunkId = null;
                        });

                        const chunkElement = document.getElementById(chunkIdToDelete);
                        if (chunkElement) chunkElement.remove();
                        drawConnections();
                        updateChunkCounter();
                        triggerAutoSave();
                    }
                }]);
            }

            // --- Selection & Visual Updates ---
            function selectChunk(chunkId) {
                state.selectedChunkId = chunkId;
                updateSelectedVisuals();
            }

            function deselectAllChunks() {
                if (state.linkingMode) cancelLinkingMode(true);
                state.selectedChunkId = null;
                updateSelectedVisuals();
            }

            function updateChunkCounter() {
                DOMElements.chunkCountDisplay.textContent = `Chunks: ${state.chunks.length}`;
            }

            function updateChunkHeaderDisplay(chunkId) {
                const chunkElement = document.getElementById(chunkId);
                const chunkData = state.chunksMap.get(chunkId);
                if (!chunkElement || !chunkData) return;
                const headerTitle = chunkElement.querySelector('.chunk-header-title');
                if (headerTitle) {
                    const shapeInfo = SHAPE_MAP[chunkData.chunkTypeTag] || { name: '?', symbol: '?', meaning: '?' };
                    const selectedColor = COLORS.find(c => c.name === chunkData.colorName) || {};
                    const truncatedMeaning = (shapeInfo.meaning || '').split(',')[0];
                    const truncatedEssence = (selectedColor.essence || '').split(',')[0];

                    headerTitle.innerHTML = `<span class="tag">${chunkData.chunkTypeTag}</span> | <span class="shape-symbol" title="${shapeInfo.name}: ${shapeInfo.meaning}">${shapeInfo.symbol}</span> <span title="${shapeInfo.name}: ${shapeInfo.meaning}">${truncatedMeaning}</span> | <span class="color-symbol ${selectedColor?.tailwindClass || ''}" title="${selectedColor?.name}: ${selectedColor?.essence}">${selectedColor?.symbol}</span> <span title="${selectedColor?.name}: ${selectedColor?.essence}">${truncatedEssence}</span>`;
                }
            }

            function updateSelectedVisuals() {
                document.querySelectorAll('.core-chunk').forEach(el => {
                    const chunkData = state.chunksMap.get(el.id);
                    if (!chunkData) return;

                    el.classList.toggle('selected-chunk', el.id === state.selectedChunkId && !state.linkingMode);
                    el.classList.toggle('linking-source-chunk', el.id === state.linkingSourceChunkId && state.linkingMode);

                    const linkButton = el.querySelector('.link-chunk-btn');
                    if (linkButton) {
                        if (el.id === state.linkingSourceChunkId && state.linkingMode) {
                            linkButton.innerHTML = ICON_LINKING_ACTIVE;
                            linkButton.title = 'Cancel Linking';
                            linkButton.classList.add('linking-active');
                        } else if (chunkData.nextChunkId) {
                            linkButton.innerHTML = ICON_UNLINK;
                            linkButton.title = 'Unlink Chunk';
                            linkButton.classList.remove('linking-active');
                        } else {
                            linkButton.innerHTML = ICON_LINK;
                            linkButton.title = 'Link to Next Chunk';
                            linkButton.classList.remove('linking-active');
                        }
                    }
                });
            }

            // --- Linking ---
            function handleLinkButtonClick(chunkId) {
                const chunkData = state.chunksMap.get(chunkId);
                if (!chunkData) return;
                if (state.linkingMode && state.linkingSourceChunkId === chunkId) {
                    cancelLinkingMode(false);
                } else if (chunkData.nextChunkId) {
                    showMessage("Unlink Chunk", `Do you want to remove the link from this chunk?`, [{
                        text: 'Cancel',
                        class: 'btn-secondary'
                    }, {
                        text: 'Unlink',
                        class: 'btn-primary',
                        action: () => {
                            chunkData.nextChunkId = null;
                            drawConnections();
                            updateSelectedVisuals();
                            triggerAutoSave();
                        }
                    }]);
                } else {
                    startLinkingMode(chunkId);
                }
            }

            function startLinkingMode(sourceId) {
                state.linkingMode = true;
                state.linkingSourceChunkId = sourceId;
                DOMElements.body.classList.add('linking-mode');
                selectChunk(sourceId);
            }

            function cancelLinkingMode(isDeselect = false) {
                state.linkingMode = false;
                const prevSourceId = state.linkingSourceChunkId;
                state.linkingSourceChunkId = null;
                DOMElements.body.classList.remove('linking-mode');
                if (isDeselect) state.selectedChunkId = null;
                else if (prevSourceId) selectChunk(prevSourceId);
                updateSelectedVisuals();
            }

            function completeLink(sourceId, targetId) {
                const sourceChunk = state.chunksMap.get(sourceId);
                if (sourceChunk) sourceChunk.nextChunkId = targetId;
                cancelLinkingMode(false);
                drawConnections();
                selectChunk(sourceId);
                triggerAutoSave();
            }

            // --- Drawing Connections ---
            function getIntersectionPointWithRect(rect, internalPoint, externalPoint) {
                const dx = externalPoint.x - internalPoint.x;
                const dy = externalPoint.y - internalPoint.y;
                const p = [-dx, dx, -dy, dy];
                const q = [internalPoint.x - rect.x, rect.x + rect.width - internalPoint.x, internalPoint.y - rect.y, rect.y + rect.height - internalPoint.y];
                let u1 = -Infinity,
                    u2 = Infinity;
                for (let i = 0; i < 4; i++) {
                    if (p[i] === 0) {
                        if (q[i] < 0) return null;
                    } else {
                        const t = q[i] / p[i];
                        if (p[i] < 0 && u1 < t) u1 = t;
                        else if (p[i] > 0 && u2 > t) u2 = t;
                    }
                }
                if (u1 > u2 || u1 > 1 || u1 < 0) {
                    if (u2 > 1 || u2 < 0) return null;
                    return {
                        x: internalPoint.x + u2 * dx,
                        y: internalPoint.y + u2 * dy
                    };
                }
                return {
                    x: internalPoint.x + u1 * dx,
                    y: internalPoint.y + u2 * dy
                };
            }

            let svgDefsCreated = false;

            function drawConnections() {
                if (!svgDefsCreated) {
                    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                    marker.setAttribute('id', 'arrowhead');
                    marker.setAttribute('viewBox', '0 0 10 10');
                    marker.setAttribute('refX', '10');
                    marker.setAttribute('refY', '5');
                    marker.setAttribute('markerUnits', 'strokeWidth');
                    marker.setAttribute('markerWidth', '6');
                    marker.setAttribute('markerHeight', '5');
                    marker.setAttribute('orient', 'auto');
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
                    path.classList.add('arrow-head');
                    marker.appendChild(path);
                    defs.appendChild(marker);
                    DOMElements.svgCanvas.appendChild(defs);
                    svgDefsCreated = true;
                }

                DOMElements.svgCanvas.querySelectorAll('line').forEach(line => line.remove());

                state.chunks.forEach(sourceChunkData => {
                    if (sourceChunkData.nextChunkId) {
                        const targetChunkData = state.chunksMap.get(sourceChunkData.nextChunkId);
                        if (targetChunkData) {
                            const sourceRect = {
                                x: sourceChunkData.x,
                                y: sourceChunkData.y,
                                width: sourceChunkData.width,
                                height: sourceChunkData.height
                            };
                            const targetRect = {
                                x: targetChunkData.x,
                                y: targetChunkData.y,
                                width: targetChunkData.width,
                                height: targetChunkData.height
                            };
                            const sourceCenter = {
                                x: sourceRect.x + sourceRect.width / 2,
                                y: sourceRect.y + sourceRect.height / 2
                            };
                            const targetCenter = {
                                x: targetRect.x + targetRect.width / 2,
                                y: targetRect.y + targetRect.height / 2
                            };

                            const startPoint = getIntersectionPointWithRect(sourceRect, sourceCenter, targetCenter) || sourceCenter;
                            const endPoint = getIntersectionPointWithRect(targetRect, targetCenter, sourceCenter) || targetCenter;

                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', String(startPoint.x));
                            line.setAttribute('y1', String(startPoint.y));
                            line.setAttribute('x2', String(endPoint.x));
                            line.setAttribute('y2', String(endPoint.y));
                            line.classList.add('connecting-line');
                            line.setAttribute('marker-end', 'url(#arrowhead)');
                            DOMElements.svgCanvas.appendChild(line);
                        }
                    }
                });
            }

            // --- Save/Load & Export ---
            function saveDataToFile() {
                state.chunks.forEach(chunkData => {
                    const chunkElement = document.getElementById(chunkData.id);
                    if (chunkElement) {
                        const contentDiv = chunkElement.querySelector('.chunk-content');
                        if (contentDiv) {
                            chunkData.text = contentDiv.innerHTML;
                        }
                    }
                });
                const dataToSave = {
                    chunks: state.chunks,
                    viewport: {
                        scale: state.scale,
                        translateX: state.translateX,
                        translateY: state.translateY
                    }
                };
                downloadFile(JSON.stringify(dataToSave, null, 2), 'core-notes.json', 'application/json');
            }

            function downloadFile(content, fileName, contentType) {
                const a = document.createElement('a');
                const file = new Blob([content], {
                    type: contentType
                });
                a.href = URL.createObjectURL(file);
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            }

            function getOrderedChunksForExport() {
                const localChunkMap = new Map(state.chunks.map(chunk => {
                    const newChunk = JSON.parse(JSON.stringify(chunk));
                    const chunkEl = document.getElementById(newChunk.id);
                    if (chunkEl) {
                        const contentDiv = chunkEl.querySelector('.chunk-content');
                        if (contentDiv) newChunk.text = contentDiv.innerHTML;
                    }
                    return [newChunk.id, newChunk];
                }));
                const orderedChunks = [];
                const visited = new Set();
                const inCurrentPath = new Set();

                const allTargetIds = new Set();
                localChunkMap.forEach(chunk => {
                    if (chunk.nextChunkId) allTargetIds.add(chunk.nextChunkId);
                });
                const startNodes = [];
                localChunkMap.forEach(chunk => {
                    if (!allTargetIds.has(chunk.id)) startNodes.push(chunk);
                });
                startNodes.sort((a, b) => a.y === b.y ? a.x - b.x : a.y - b.y);


                function traverse(chunkId) {
                    if (!chunkId || visited.has(chunkId)) return;
                    if (inCurrentPath.has(chunkId)) {
                        console.warn("Cycle detected involving chunk:", chunkId, ". Breaking traversal for this path.");
                        return;
                    }

                    visited.add(chunkId);
                    inCurrentPath.add(chunkId);
                    const chunk = localChunkMap.get(chunkId);
                    if (chunk) {
                        orderedChunks.push(chunk);
                        if (chunk.nextChunkId) {
                            traverse(chunk.nextChunkId);
                        }
                    }
                    inCurrentPath.delete(chunkId);
                }

                startNodes.forEach(startNode => traverse(startNode.id));

                const orphanedChunks = [];
                localChunkMap.forEach(chunk => {
                    if (!visited.has(chunk.id)) orphanedChunks.push(chunk);
                });
                orphanedChunks.sort((a, b) => {
                    if (a.y !== b.y) return a.y - b.y;
                    return a.x - b.x;
                });
                orderedChunks.push(...orphanedChunks);
                return orderedChunks;
            }

            function getCombinedText() {
                const exportOrderChunks = getOrderedChunksForExport();
                return exportOrderChunks.map(chunk => {
                    let linkInfo = "";
                    if (chunk.nextChunkId) {
                        const targetChunkData = state.chunksMap.get(chunk.nextChunkId);
                        if (targetChunkData) {
                            linkInfo = `\n  -> Links to: ${targetChunkData.chunkTypeTag}`;
                        }
                    }
                    const shapeInfo = SHAPE_MAP[chunk.chunkTypeTag] || { symbol: '?', meaning: '?'};
                    const color = COLORS.find(c => c.name === chunk.colorName) || { symbol: '?', essence: '?'};
                    const header = `${chunk.chunkTypeTag} | ${shapeInfo.symbol} ${shapeInfo.meaning?.split(',')[0]} | ${color.symbol} ${color.essence?.split(',')[0]}`;
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = chunk.text;
                    const plainText = tempDiv.textContent || tempDiv.innerText || "";
                    return `${header}\n${plainText}${linkInfo}\n\n---\n`;
                }).join('');
            }
            
            function generateOpmlContent() {
                const orderedChunks = getOrderedChunksForExport();
                const title = "CORE Notes Export";
                const creationDate = new Date().toUTCString();

                let opmlBody = '';
                const chunkMap = new Map(orderedChunks.map(chunk => [chunk.id, chunk]));
                const processed = new Set();

                function textToXml(text) {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = text;
                    const plainText = (tempDiv.textContent || tempDiv.innerText || "").trim();
                    return plainText.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
                }
                
                function buildNestedOutline(chunkId) {
                    if (!chunkId || !chunkMap.has(chunkId) || processed.has(chunkId)) {
                        return '';
                    }
                    processed.add(chunkId);
                    const chunk = chunkMap.get(chunkId);
                    
                    const shapeInfo = SHAPE_MAP[chunk.chunkTypeTag] || {};
                    const color = COLORS.find(c => c.name === chunk.colorName) || {};
                    const outlineTitle = `${shapeInfo.symbol || ''} ${color.symbol || ''} ${chunk.chunkTypeTag}`.trim();

                    let outline = `        <outline text="${textToXml(outlineTitle)}">\n`;
                    const chunkContent = textToXml(chunk.text);
                    if (chunkContent) {
                       outline += `            <outline text="${chunkContent}"/>\n`;
                    }

                    if (chunk.nextChunkId) {
                        outline += buildNestedOutline(chunk.nextChunkId);
                    }
                    
                    outline += '        </outline>\n';
                    return outline;
                }


                orderedChunks.forEach(chunk => {
                    if (!processed.has(chunk.id)) {
                        opmlBody += buildNestedOutline(chunk.id);
                    }
                });

                return `<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
    <head>
        <title>${title}</title>
        <dateCreated>${creationDate}</dateCreated>
    </head>
    <body>
${opmlBody}
    </body>
</opml>`;
            }

            // --- Interaction Logic (Pan, Zoom, Drag, Resize) ---
            const getPointerCoordinates = e => e.touches ? ({
                x: e.touches[0].clientX,
                y: e.touches[0].clientY,
                count: e.touches.length
            }) : ({
                x: e.clientX,
                y: e.clientY,
                count: e.buttons === 1 ? 1 : 0
            });

            function getPinchDistance(e) {
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                return Math.sqrt(Math.pow(t1.clientX - t2.clientX, 2) + Math.pow(t1.clientY - t2.clientY, 2));
            }

            function onInteractionStart(e) {
                if (e.touches && e.touches.length > 1) {
                    e.preventDefault();
                    state.currentAction = 'pinch';
                    state.initialPinchDistance = getPinchDistance(e);
                    return;
                }

                const pointer = getPointerCoordinates(e);
                let targetElement = e.target;
                let actionTarget = null;

                if (targetElement.classList.contains('resize-handle')) actionTarget = 'resize';
                else if (targetElement.closest('.chunk-header') && !targetElement.closest('.chunk-action-btn')) actionTarget = 'drag';
                else if (targetElement === DOMElements.noteCanvasContainer || targetElement === DOMElements.transformContainer || targetElement === DOMElements.noteCanvas) actionTarget = 'pan';

                if (actionTarget === 'pan') {
                    if (state.linkingMode) {
                        deselectAllChunks();
                        return;
                    }
                    state.currentAction = 'pan';
                    state.panStartX = pointer.x - state.translateX;
                    state.panStartY = pointer.y - state.translateY;
                    DOMElements.noteCanvasContainer.classList.add('panning');
                } else if (actionTarget === 'drag' || actionTarget === 'resize') {
                    const chunkEl = targetElement.closest('.core-chunk');
                    if (!chunkEl) return;
                    selectChunk(chunkEl.id);
                    chunkEl.style.zIndex = String(++state.highestZIndex);
                    state.chunksMap.get(chunkEl.id).zIndex = state.highestZIndex;

                    if (actionTarget === 'resize') {
                        state.currentAction = 'resize';
                        state.interactionStartX = pointer.x;
                        state.interactionStartY = pointer.y;
                        state.startWidth = chunkEl.offsetWidth;
                        state.startHeight = chunkEl.offsetHeight;
                    } else { // drag
                        state.currentAction = 'drag';
                        const worldPointer = screenToWorld(pointer.x, pointer.y);
                        state.offsetX = worldPointer.x - chunkEl.offsetLeft;
                        state.offsetY = worldPointer.y - chunkEl.offsetTop;
                    }
                } else {
                    return;
                }

                document.addEventListener('mousemove', onInteractionMove);
                document.addEventListener('mouseup', onInteractionEnd);
                document.addEventListener('touchmove', onInteractionMove, {
                    passive: false
                });
                document.addEventListener('touchend', onInteractionEnd);
            }

            function onInteractionMove(e) {
                if (!state.currentAction) return;
                e.preventDefault();

                if (state.currentAction === 'pinch' && e.touches.length === 2) {
                    const newPinchDistance = getPinchDistance(e);
                    const scaleFactor = newPinchDistance / state.initialPinchDistance;
                    state.initialPinchDistance = newPinchDistance;

                    const rect = DOMElements.noteCanvasContainer.getBoundingClientRect();
                    const t1 = e.touches[0];
                    const t2 = e.touches[1];
                    const centerX = (t1.clientX + t2.clientX) / 2 - rect.left;
                    const centerY = (t1.clientY + t2.clientY) / 2 - rect.top;

                    const worldX = (centerX - state.translateX) / state.scale;
                    const worldY = (centerY - state.translateY) / state.scale;

                    const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, state.scale * scaleFactor));
                    state.translateX = centerX - worldX * newScale;
                    state.translateY = centerY - worldY * newScale;
                    state.scale = newScale;

                    applyTransform();
                    return;
                }

                const pointer = getPointerCoordinates(e);

                requestAnimationFrame(() => {
                    if (state.currentAction === 'pan') {
                        state.translateX = pointer.x - state.panStartX;
                        state.translateY = pointer.y - state.panStartY;
                        applyTransform();
                    } else if (state.currentAction === 'drag') {
                        const chunkEl = document.getElementById(state.selectedChunkId);
                        const chunkData = state.chunksMap.get(state.selectedChunkId);
                        if (!chunkEl || !chunkData) return;
                        const worldPointer = screenToWorld(pointer.x, pointer.y);

                        chunkData.x = Math.max(0, worldPointer.x - state.offsetX);
                        chunkData.y = Math.max(0, worldPointer.y - state.offsetY);

                        chunkEl.style.left = `${chunkData.x}px`;
                        chunkEl.style.top = `${chunkData.y}px`;
                        drawConnections();
                    } else if (state.currentAction === 'resize') {
                        const chunkEl = document.getElementById(state.selectedChunkId);
                        const chunkData = state.chunksMap.get(state.selectedChunkId);
                        if (!chunkEl || !chunkData) return;
                        const deltaX = (pointer.x - state.interactionStartX) / state.scale;
                        const deltaY = (pointer.y - state.interactionStartY) / state.scale;

                        chunkData.width = Math.max(200, state.startWidth + deltaX);
                        chunkData.height = Math.max(100, state.startHeight + deltaY);

                        chunkEl.style.width = `${chunkData.width}px`;
                        chunkEl.style.height = `${chunkData.height}px`;
                        drawConnections();
                    }
                });
            }

            function onInteractionEnd(e) {
                let stateChanged = false;
                if (state.currentAction === 'pinch' && e.touches.length < 2) {
                    state.currentAction = null;
                    state.initialPinchDistance = null;
                    stateChanged = true;
                } else if (state.currentAction === 'drag' || state.currentAction === 'resize') {
                    const chunkEl = document.getElementById(state.selectedChunkId);
                    const chunkData = state.chunksMap.get(state.selectedChunkId);
                    if (chunkEl && chunkData) {
                        chunkData.x = chunkEl.offsetLeft;
                        chunkData.y = chunkEl.offsetTop;
                        chunkData.width = chunkEl.offsetWidth;
                        chunkData.height = chunkEl.offsetHeight;
                        stateChanged = true;
                    }
                } else if (state.currentAction === 'pan') {
                    DOMElements.noteCanvasContainer.classList.remove('panning');
                    stateChanged = true;
                }

                if (stateChanged) {
                    triggerAutoSave();
                }

                if (!e.touches || e.touches.length === 0) {
                    state.currentAction = null;
                    document.removeEventListener('mousemove', onInteractionMove);
                    document.removeEventListener('mouseup', onInteractionEnd);
                    document.removeEventListener('touchmove', onInteractionMove);
                    document.removeEventListener('touchend', onInteractionEnd);
                }
            }

            // --- Event Listeners Setup ---
            function setupEventListeners() {
                window.addEventListener('beforeunload', (e) => {
                    if (state.chunks.length > 0) {
                         e.preventDefault();
                         e.returnValue = '';
                    }
                });

                DOMElements.noteCanvasContainer.addEventListener('mousedown', onInteractionStart);
                DOMElements.noteCanvasContainer.addEventListener('touchstart', onInteractionStart, {
                    passive: false
                });
                DOMElements.noteCanvasContainer.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const rect = DOMElements.noteCanvasContainer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    const worldXBeforeZoom = (mouseX - state.translateX) / state.scale;
                    const worldYBeforeZoom = (mouseY - state.translateY) / state.scale;

                    const delta = e.deltaY * ZOOM_SENSITIVITY * -1;
                    const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, state.scale * (1 + delta)));

                    state.translateX = mouseX - worldXBeforeZoom * newScale;
                    state.translateY = mouseY - worldYBeforeZoom * newScale;
                    state.scale = newScale;

                    applyTransform();
                    triggerAutoSave();
                }, {
                    passive: false
                });

                DOMElements.addChunkBtn.addEventListener('click', () => showModal(DOMElements.addChunkModal));
                DOMElements.centerLastBtn.addEventListener('click', () => {
                    if (state.lastAddedChunkId) centerOnChunk(state.lastAddedChunkId);
                });
                DOMElements.shuffleChunksBtn.addEventListener('click', shuffleChunks);
                DOMElements.spiralLayoutBtn.addEventListener('click', applySpiralLayout);
                DOMElements.summarizeBtn.addEventListener('click', summarizeBoard);
                DOMElements.clearCanvasBtn.addEventListener('click', () => {
                    if (state.chunks.length === 0) {
                        showMessage("Canvas Empty", "The canvas is already clear.");
                        return;
                    }
                    showMessage("Confirm Clear", "Are you sure you want to clear the entire canvas? This action cannot be undone.", [{
                        text: 'Cancel',
                        class: 'btn-secondary'
                    }, {
                        text: 'Clear Canvas',
                        class: 'btn-danger',
                        action: () => {
                            state.lastDeletedChunk = null; 
                            renderBoard([]);
                            clearAutoSave(); 
                            showMessage("Canvas Cleared", "All notes and links have been removed.");
                        }
                    }]);
                });
                
                DOMElements.undoDeleteBtn.addEventListener('click', () => {
                    if (state.lastDeletedChunk) {
                        const chunkData = state.lastDeletedChunk;
                        state.chunks.push(chunkData);
                        state.chunksMap.set(chunkData.id, chunkData);
                        createChunkElement(chunkData);

                        if (chunkData.zIndex > state.highestZIndex) {
                             state.highestZIndex = chunkData.zIndex;
                        }
                        drawConnections();
                        updateChunkCounter();
                        triggerAutoSave();

                        state.lastDeletedChunk = null;
                        DOMElements.undoDeleteBtn.disabled = true;
                    }
                });

                const zoom = (factor) => {
                    const rect = DOMElements.noteCanvasContainer.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;

                    const worldXBeforeZoom = (centerX - state.translateX) / state.scale;
                    const worldYBeforeZoom = (centerY - state.translateY) / state.scale;

                    const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, state.scale * factor));

                    state.translateX = centerX - worldXBeforeZoom * newScale;
                    state.translateY = centerY - worldYBeforeZoom * newScale;
                    state.scale = newScale;

                    applyTransform();
                    triggerAutoSave();
                };

                DOMElements.zoomInBtn.addEventListener('click', () => zoom(1.25));
                DOMElements.zoomOutBtn.addEventListener('click', () => zoom(0.8));
                DOMElements.zoomResetBtn.addEventListener('click', resetAndCenterView);

                DOMElements.saveBtn.addEventListener('click', saveDataToFile);
                DOMElements.loadBtn.addEventListener('click', () => DOMElements.fileLoadInput.click());
                DOMElements.fileLoadInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const loadedData = JSON.parse(e.target.result);
                            if (loadedData && Array.isArray(loadedData.chunks)) {
                                renderBoard(loadedData.chunks); 
                                if (loadedData.viewport) {
                                    state.scale = loadedData.viewport.scale || 1;
                                    state.translateX = loadedData.viewport.translateX || 0;
                                    state.translateY = loadedData.viewport.translateY || 0;
                                    applyTransform();
                                    triggerAutoSave();
                                }
                            }
                        } catch (error) {
                            showMessage("Load Error", `Could not parse file: ${error.message}`);
                        }
                    };
                    reader.readAsText(file);
                    event.target.value = null;
                });

                DOMElements.exportBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const dropdown = DOMElements.exportDropdown;
                    dropdown.classList.toggle('hidden');
                });
                document.addEventListener('click', (e) => {
                    if (!DOMElements.exportBtn.contains(e.target) && !DOMElements.exportDropdown.contains(e.target)) {
                        DOMElements.exportDropdown.classList.add('hidden');
                    }
                });
                DOMElements.exportTxtBtn.addEventListener('click', () => {
                    if (state.chunks.length === 0) {
                        showMessage("Empty Board", "Nothing to export.");
                        return;
                    }
                    const text = getCombinedText();
                    downloadFile(text, 'core-notes.txt', 'text/plain');
                    DOMElements.exportDropdown.classList.add('hidden');
                });
                DOMElements.exportHtmlBtn.addEventListener('click', () => {
                    if (state.chunks.length === 0) {
                        showMessage("Empty Board", "Nothing to export.");
                        return;
                    }
                    const exportOrderChunks = getOrderedChunksForExport();
                    let htmlContent = `<html><head><title>CORE Notes</title><style>body{font-family:sans-serif; line-height:1.6;} .chunk{border:1px solid #eee; margin-bottom:20px; padding:15px; border-radius:5px; box-shadow: 2px 2px 5px #ccc;} h3{margin-top:0; font-size:1.1em; color:#333; border-bottom:1px solid #eee; padding-bottom:5px;} .chunk-meta{font-size:0.9em; color:#777;} .chunk-meta span[title]{cursor:help; border-bottom: 1px dotted #777;} .link-info{font-style:italic; color:#555; font-size:0.85em;}</style></head><body><h1>CORE Notes</h1>`;
                    exportOrderChunks.forEach(chunk => {
                        const shapeInfo = SHAPE_MAP[chunk.chunkTypeTag] || {};
                        const color = COLORS.find(c => c.name === chunk.colorName) || {};
                        const shapeHtml = `<span title="${shapeInfo.name}: ${shapeInfo.meaning}">${shapeInfo.symbol} ${shapeInfo.meaning?.split(',')[0]}</span>`;
                        const colorHtml = `<span title="${color.name}: ${color.essence}">${color.symbol} ${color.essence?.split(',')[0]}</span>`;
                        const headerMeta = `${chunk.chunkTypeTag} &bull; ${shapeHtml} &bull; ${colorHtml}`;
                        let linkInfoHtml = "";
                        if (chunk.nextChunkId) {
                            const targetChunkData = state.chunksMap.get(chunk.nextChunkId);
                            if (targetChunkData) {
                                linkInfoHtml = `<div class="link-info">Links to: ${targetChunkData.chunkTypeTag}</div>`;
                            }
                        }
                        htmlContent += `<div class="chunk"><h3>${chunk.chunkTypeTag}</h3><div class="chunk-meta">${headerMeta}</div><div>${chunk.text}</div>${linkInfoHtml}</div>`;
                    });
                    htmlContent += '</body></html>';
                    downloadFile(htmlContent, 'core-notes.html', 'text/html');
                    DOMElements.exportDropdown.classList.add('hidden');
                });
                DOMElements.exportMdBtn.addEventListener('click', () => {
                    if (state.chunks.length === 0) {
                        showMessage("Empty Board", "Nothing to export.");
                        return;
                    }
                    const exportOrderChunks = getOrderedChunksForExport();
                    let mdContent = '# CORE Notes\n\n';
                    exportOrderChunks.forEach(chunk => {
                        const shapeInfo = SHAPE_MAP[chunk.chunkTypeTag] || {};
                        const color = COLORS.find(c => c.name === chunk.colorName) || {};
                        const headerMeta = `${chunk.chunkTypeTag} • ${shapeInfo.symbol} ${shapeInfo.meaning?.split(',')[0]} • ${color.symbol} ${color.essence?.split(',')[0]}`;

                        let textContent = chunk.text;
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = textContent;
                        tempDiv.querySelectorAll('p').forEach(p => {
                            p.insertAdjacentText('afterend', '\n\n');
                            p.replaceWith(...p.childNodes);
                        });
                        tempDiv.querySelectorAll('br').forEach(br => br.replaceWith('\n'));
                        tempDiv.querySelectorAll('strong, b').forEach(s => s.replaceWith(`**${s.textContent}**`));
                        tempDiv.querySelectorAll('em, i').forEach(e => e.replaceWith(`*${e.textContent}*`));
                        tempDiv.querySelectorAll('a').forEach(a => a.replaceWith(`[${a.textContent}](${a.href})`));
                        textContent = (tempDiv.textContent || tempDiv.innerText || "").trim();

                        mdContent += `## ${chunk.chunkTypeTag}\n`;
                        mdContent += `*Metadata: ${headerMeta}*\n\n`;
                        mdContent += `${textContent}\n`;

                        if (chunk.nextChunkId) {
                            const targetChunkData = state.chunksMap.get(chunk.nextChunkId);
                            if (targetChunkData) {
                                mdContent += `\n  *→ Links to: ${targetChunkData.chunkTypeTag}*\n`;
                            }
                        }
                        mdContent += `\n---\n\n`;
                    });
                    downloadFile(mdContent, 'core-notes.md', 'text/markdown');
                    DOMElements.exportDropdown.classList.add('hidden');
                });
                
                DOMElements.exportOpmlBtn.addEventListener('click', () => {
                    if (state.chunks.length === 0) {
                        showMessage("Empty Board", "Nothing to export.");
                        return;
                    }
                    const opmlContent = generateOpmlContent();
                    downloadFile(opmlContent, 'core-notes.opml', 'application/xml');
                    DOMElements.exportDropdown.classList.add('hidden');
                });


                DOMElements.settingsBtn.addEventListener('click', () => {
                    originalTheme = DOMElements.themeSelect.value;
                    showModal(DOMElements.settingsModal)
                });
                DOMElements.saveSettingsBtn.addEventListener('click', saveSettings);
                DOMElements.cancelSettingsBtn.addEventListener('click', cancelSettings);
                DOMElements.closeSettingsModalBtn.addEventListener('click', cancelSettings);
                DOMElements.themeSelect.addEventListener('change', (e) => {
                    applyTheme(e.target.value);
                });

                DOMElements.helpBtn.addEventListener('click', () => showModal(DOMElements.helpModal));
                DOMElements.donateBtn.addEventListener('click', () => {
                    showMessage(
                        "Support CORE",
                        `Thank you for considering a donation! This project is developed and maintained by an independent creator. Your support helps keep the app free and growing.<br><br>You can support the project here: <a href="https://ko-fi.com/thorstenbecker" target="_blank" class="text-[var(--color-primary)] hover:underline">Ko-fi.com/thorstenbecker</a>`,
                        [{
                            text: 'OK',
                            class: 'btn-primary'
                        }]
                    );
                });

                DOMElements.confirmAddChunkBtn.addEventListener('click', () => {
                    const type = ALL_CHUNK_TYPES.find(ct => ct.tag === DOMElements.chunkTypeSelect.value);
                    const color = COLORS.find(c => c.name === DOMElements.chunkColorSelect.value);
                    if (type && color) {
                        addChunkToCanvas({ type, color });
                        hideModal(DOMElements.addChunkModal);
                    }
                });
                DOMElements.confirmEditChunkBtn.addEventListener('click', () => {
                    const chunkId = DOMElements.editingChunkIdInput.value;
                    const chunkData = state.chunksMap.get(chunkId);

                    if (chunkData) {
                        const newTag = DOMElements.editChunkTypeSelect.value;
                        const shapeInfo = SHAPE_MAP[newTag] || { name: 'Default' };
                        chunkData.chunkTypeTag = newTag;
                        chunkData.shapeName = shapeInfo.name;
                        chunkData.colorName = DOMElements.editChunkColorSelect.value;

                        updateChunkHeaderDisplay(chunkId);
                        hideModal(DOMElements.editChunkModal);
                        triggerAutoSave();
                    } else {
                        showMessage("Error", "Could not find the chunk to update.");
                    }
                });
                [DOMElements.cancelAddChunkBtn, DOMElements.cancelEditChunkBtn, DOMElements.closeHelpModalSpan, DOMElements.closeHelpBtn].forEach(el => el.addEventListener('click', () => hideModal(el.closest('.modal'))));
                
                // AI Modal Listeners
                DOMElements.closeAiActionModalBtn.addEventListener('click', () => hideModal(DOMElements.aiActionModal));
                DOMElements.cancelAiActionBtn.addEventListener('click', () => hideModal(DOMElements.aiActionModal));

                const handleAiAction = async (actionType) => {
                     if (!state.geminiApiKey) {
                        showMessage("API Key Required", "Please set your Google AI API key in the Settings menu to use this feature.");
                        return;
                    }
                    if (!state.activeAiChunkId) {
                        showMessage("Error", "No active chunk selected for AI action.");
                        return;
                    }
                    showMessage("AI Assistant", "This AI feature is not fully implemented in this version.", [{ text: 'OK', class: 'btn-primary' }]);
                    // Placeholder for future implementation
                };

                DOMElements.aiActionGenerateBtn.addEventListener('click', () => handleAiAction('generate'));
                DOMElements.aiActionSuggestNextBtn.addEventListener('click', () => handleAiAction('suggest'));


                DOMElements.continueSessionBtn.addEventListener('click', () => {
                    hideModal(DOMElements.sessionRestoreModal);
                    renderBoard(state.chunks);
                    applyTransform();
                });

                DOMElements.startFreshBtn.addEventListener('click', () => {
                    hideModal(DOMElements.sessionRestoreModal);
                    clearAutoSave();
                    state.chunks = []; 
                    state.lastDeletedChunk = null;
                    state.lastAddedChunkId = null;
                    renderBoard([]);
                    resetAndCenterView();
                });


                document.addEventListener('keydown', (e) => {
                    const activeEl = document.activeElement;
                    const isInputFocused = activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable;

                    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
                        if(!isInputFocused){ 
                           e.preventDefault();
                           DOMElements.undoDeleteBtn.click();
                        }
                    }

                    if (!DOMElements.body.querySelector('.modal:not(.hidden)')) {
                        if (!isInputFocused) {
                            let handled = true;
                            switch (e.key.toLowerCase()) {
                                case 'a':
                                    DOMElements.addChunkBtn.click();
                                    break;
                                case 'c':
                                    DOMElements.centerLastBtn.click();
                                    break;
                                case 'delete':
                                case 'backspace':
                                    if (state.selectedChunkId) deleteChunk(state.selectedChunkId);
                                    break;
                                case 'escape':
                                    deselectAllChunks();
                                    break;
                                case '+':
                                case '=':
                                    DOMElements.zoomInBtn.click();
                                    break;
                                case '-':
                                    DOMElements.zoomOutBtn.click();
                                    break;
                                case '0':
                                    DOMElements.zoomResetBtn.click();
                                    break;
                                default:
                                    handled = false;
                            }
                            if (handled) e.preventDefault();
                        }
                    }
                });
            }

            function populateSelectWithOptions(selectElement, optionsArray, currentValue, groups = null, groupLabelFormatterFn = null) {
                selectElement.innerHTML = '';
                if (groups && groupLabelFormatterFn) {
                    for (const groupKey in groups) {
                        if (groups.hasOwnProperty(groupKey)) {
                            const groupItems = groups[groupKey];
                            const optgroup = document.createElement('optgroup');
                            optgroup.label = groupLabelFormatterFn(groupKey);
                            groupItems.forEach(item => {
                                const option = document.createElement('option');
                                option.value = item.tag;
                                option.textContent = `${item.tag} - ${item.description}`;
                                if (item.tag === currentValue) option.selected = true;
                                optgroup.appendChild(option);
                            });
                            selectElement.appendChild(optgroup);
                        }
                    }
                } else if (optionsArray) {
                    optionsArray.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.value;
                        option.textContent = opt.text;
                        if (opt.value === currentValue) option.selected = true;
                        selectElement.appendChild(option);
                    });
                }
            }

            function populateAddChunkModal() {
                const formatGroupLabel = (key) => key.charAt(0).toUpperCase() + key.slice(1) + " Chunks";
                populateSelectWithOptions(DOMElements.chunkTypeSelect, null, null, CHUNK_TYPES, formatGroupLabel);
                populateSelectWithOptions(DOMElements.chunkColorSelect, COLORS.map(c => ({
                    value: c.name,
                    text: `${c.symbol} ${c.name} - ${c.essence}`
                })), COLORS[0].name);
            }

            function populateHelpModal() {
                const createChunkList = (category) => {
                    return category.map(chunk => {
                        const shapeInfo = SHAPE_MAP[chunk.tag] || { symbol: '?', name: '' };
                        return `<li><b>${chunk.tag} (${shapeInfo.symbol} ${shapeInfo.name}):</b> ${chunk.description}</li>`;
                    }).join('');
                };

                const coreChunksList = createChunkList(CHUNK_TYPES.core);
                const optionalChunksList = createChunkList(CHUNK_TYPES.optional);
                const narrativeChunksList = createChunkList(CHUNK_TYPES.narrative);
                const conceptualChunksList = createChunkList(CHUNK_TYPES.conceptual);
                const colorsList = COLORS.map(c => `<li><b>${c.symbol} ${c.name}:</b> ${c.essence}</li>`).join('');

                DOMElements.helpContent.innerHTML = `
                <h3>What is CORE?</h3>
                <p>CORE is for those who think in constellations, not straight lines. It offers structure without rigidity, and clarity without collapse. It is more than a way to arrange notes – it is a way to navigate your own cognition and express it.</p>
                <p>You can read about the <a href="https://drive.google.com/file/d/15njaD0LPsVdUU8gsZBXOe9anoBYI02Ct/view?usp=sharing" target="_blank" class="text-[var(--color-primary)] hover:underline">full concept of CORE here</a>.</p>
                <p>It gives form to cognitive movement, showing how meaning drifts, circles, or crystallizes over time. CORE does not ask you to tame your thoughts into tidy lists; it asks you to place them, tag them, color them, and connect what matters.</p>

                <h3>The CORE Loop</h3>
                <p>CORE provides a rhythm for turning thoughts into tangible output: Chunk, Orient, Relate, Express.</p>
                <ul>
                    <li><b>Chunk:</b> Break ideas into self-contained blocks. Assign one tag (its function) and one color (its emotional tone).</li>
                    <li><b>Orient:</b> Place chunks spatially. Let proximity suggest importance; clusters indicate themes.</li>
                    <li><b>Relate:</b> Draw arrows to show flow and connection between ideas.</li>
                    <li><b>Express:</b> When the map feels right, turn it into an outline, draft, or action list.</li>
                </ul>
                
                <h3>App Features</h3>
                <p>Your work is <b>automatically saved</b> to your browser. When you return, you can continue your last session or start fresh.</p>
                <ul>
                    <li><b>Settings (⚙️):</b> Configure the app's theme, view options, and add your Google AI API key for AI features.</li>
                    <li><b>AI Assistant (✨):</b> Click the 'sparkle' icon in a chunk's header to open the AI Assistant. Use it to rewrite content, brainstorm, and more.</li>
                    <li><b>Summarize Board:</b> Click 'Summarize' in the toolbar to get a high-level summary of all notes on your canvas.</li>
                    <li><b>Save/Load/Export:</b> Use the toolbar buttons to save a permanent backup file, load a file, or export your work to TXT, HTML, Markdown, or OPML for use in other apps.</li>
                </ul>

                <h3>Keyboard Shortcuts</h3>
                <p>
                    <code>A</code>: Add Chunk | <code>C</code>: Center on Last | <code>Esc</code>: Deselect / Close Modals <br>
                    <code>Del</code>/<code>Backspace</code>: Delete Selected | <code>+/-</code>/<code>=</code>: Zoom | <code>0</code>: Reset Zoom<br>
                    <code>Ctrl/Cmd + S</code>: Save | <code>Ctrl/Cmd + O</code>: Load | <code>Ctrl/Cmd + Z</code>: Undo Delete
                </p>

                <h3>Chunk Types</h3>
                <p>A chunk's shape is determined by its functional tag. You select the chunk's purpose, and the shape is assigned automatically.</p>
                
                <h4>Main Chunks</h4>
                <ul>${coreChunksList}</ul>

                <h4>Optional Chunks (Formal/Analytical)</h4>
                <ul>${optionalChunksList}</ul>

                <h4>Narrative Extensions</h4>
                <ul>${narrativeChunksList}</ul>
                
                <h4>Conceptual Add-ons</h4>
                <ul>${conceptualChunksList}</ul>

                <h3>Color Tags (Emotional Cues)</h3>
                <p>Color is used to signal the emotional tone or temperature of a chunk. It is independent of the chunk's structural role.</p>
                <ul>${colorsList}</ul>

                <h3>Usage & Licensing</h3>
                <p><strong>Free for Individual Creators:</strong><br>
                CORE is free for individual writers, students, researchers, and creatives. If you find it helpful, please consider a donation to support its development.</p>
                <p class="mt-4"><strong>License Required for Organizational Use:</strong><br>
                A license is required for use within a company, team, or formal organization (e.g., in a corporate writing room, as a mandated tool for a team). For licensing inquiries, please contact <b>hello@thorstenbecker.de</b>.</p>
            `;
            }

            function shuffleChunks() {
                if (state.chunks.length < 2) {
                    showMessage("Not Enough Chunks", "You need at least two chunks on the canvas to shuffle.");
                    return;
                }
                const PADDING = 50;
                let minX = Infinity,
                    minY = Infinity,
                    maxX = -Infinity,
                    maxY = -Infinity;

                state.chunks.forEach(chunk => {
                    minX = Math.min(minX, chunk.x);
                    minY = Math.min(minY, chunk.y);
                    maxX = Math.max(maxX, chunk.x + chunk.width);
                    maxY = Math.max(maxY, chunk.y + chunk.height);
                });

                const bboxWidth = maxX - minX;
                const bboxHeight = maxY - minY;

                state.chunks.forEach(chunkData => {
                    const chunkEl = document.getElementById(chunkData.id);
                    if (chunkEl) {
                        chunkData.x = minX + Math.random() * (bboxWidth - chunkData.width);
                        chunkData.y = minY + Math.random() * (bboxHeight - chunkData.height);
                        chunkEl.style.left = chunkData.x + 'px';
                        chunkEl.style.top = chunkData.y + 'px';
                    }
                });
                drawConnections();
                triggerAutoSave();
            }

            function applySpiralLayout() {
                const orderedChunks = getOrderedChunksForExport();
                if (orderedChunks.length < 1) {
                    showMessage("Not Enough Chunks", "You need at least one chunk to create a spiral layout.");
                    return;
                }

                const isClockwise = state.spiralClockwise;
                state.spiralClockwise = !state.spiralClockwise;

                const canvasCenterX = 4000;
                const canvasCenterY = 3000;

                const PADDING = 100;
                const INITIAL_OFFSET = 250;
                const SPIRAL_SEPARATION_FACTOR = 45;
                const directionMultiplier = isClockwise ? 1 : -1;

                let effective_angle = 0;

                for (let i = 0; i < orderedChunks.length; i++) {
                    const chunkData = state.chunksMap.get(orderedChunks[i].id);
                    const chunkEl = document.getElementById(orderedChunks[i].id);
                    const prevChunkData = (i > 0) ? state.chunksMap.get(orderedChunks[i - 1].id) : null;

                    if (i > 0) {
                        const requiredSpacing = (Math.max(prevChunkData.width, prevChunkData.height) / 2) +
                            (Math.max(chunkData.width, chunkData.height) / 2) +
                            PADDING;
                        const prevChunkCenter = {
                            x: prevChunkData.x + prevChunkData.width / 2,
                            y: prevChunkData.y + prevChunkData.height / 2
                        };
                        const prevRadius = Math.sqrt(
                            Math.pow(prevChunkCenter.x - canvasCenterX, 2) +
                            Math.pow(prevChunkCenter.y - canvasCenterY, 2)
                        );
                        if (prevRadius > 0) {
                            effective_angle += requiredSpacing / prevRadius;
                        } else {
                            effective_angle += 1.5;
                        }
                    }

                    const radius = INITIAL_OFFSET + SPIRAL_SEPARATION_FACTOR * effective_angle;
                    const total_angle = (3 * Math.PI / 2) + (effective_angle * directionMultiplier);
                    const newCenterX = canvasCenterX + radius * Math.cos(total_angle);
                    const newCenterY = canvasCenterY + radius * Math.sin(total_angle);

                    chunkData.x = newCenterX - (chunkData.width / 2);
                    chunkData.y = newCenterY - (chunkData.height / 2);
                    chunkEl.style.left = chunkData.x + 'px';
                    chunkEl.style.top = chunkData.y + 'px';
                }

                drawConnections();
                triggerAutoSave();
                const directionText = isClockwise ? "Clockwise" : "Counter-Clockwise";
                showMessage("Layout Updated", `Chunks arranged in a ${directionText} spiral.`);
            }

            async function summarizeBoard() {
                if (!state.geminiApiKey) {
                    showMessage("API Key Required", "Please set your Google AI API key in the Settings menu to use this feature.");
                    return;
                }
                if (state.chunks.length === 0) {
                    showMessage("Empty Canvas", "There is nothing to summarize. Add some chunks first.");
                    return;
                }

                showMessage("AI Summarization", "The AI is reading your notes and generating a summary. This may take a moment...", [{
                    text: 'Working...',
                    class: 'btn-primary',
                    noHide: true
                }]);

                const fullText = getCombinedText();
                const prompt = `Please provide a concise, high-level summary of the following notes from a creative writing project. The notes are organized into chunks with different types. Focus on the core themes, character arcs, and major plot points. The notes are:\n\n---\n\n${fullText}`;

                try {
                    let chatHistory = [{
                        role: "user",
                        parts: [{
                            text: prompt
                        }]
                    }];
                    const payload = {
                        contents: chatHistory
                    };
                    const apiKey = state.geminiApiKey;
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0) {
                        const summaryText = result.candidates[0].content.parts[0].text.replace(/\n/g, '<br>');
                        showMessage("AI Summary", summaryText);
                    } else {
                        throw new Error("No summary was returned from the API.");
                    }

                } catch (error) {
                    showMessage("AI Error", `Could not generate summary: ${error.message}`);
                    console.error(error);
                }
            }

            function openEditChunkModal(chunkId) {
                const chunkData = state.chunksMap.get(chunkId);
                if (!chunkData) return;
                DOMElements.editingChunkIdInput.value = chunkId;

                const formatGroupLabel = (key) => key.charAt(0).toUpperCase() + key.slice(1) + " Chunks";
                populateSelectWithOptions(DOMElements.editChunkTypeSelect, null, chunkData.chunkTypeTag, CHUNK_TYPES, formatGroupLabel);
                populateSelectWithOptions(DOMElements.editChunkColorSelect, COLORS.map(c => ({
                    value: c.name,
                    text: `${c.symbol} ${c.name}`
                })), chunkData.colorName);

                showModal(DOMElements.editChunkModal);
            }

            function openAiModal(chunkId) {
                state.activeAiChunkId = chunkId;
                DOMElements.aiPromptTextarea.value = ''; // Clear previous prompt
                showModal(DOMElements.aiActionModal);
            }

            // --- Initialization ---
            function initializeApp() {
                document.getElementById('copyrightYear').textContent = new Date().getFullYear();
                loadSettings();
                populateAddChunkModal();
                populateHelpModal();
                setupEventListeners();

                const wasSessionFound = loadSessionFromAutoSave();

                if (!wasSessionFound) {
                    renderBoard([]);
                    resetAndCenterView();
                }
                
                setTimeout(() => DOMElements.noteCanvasContainer.focus(), 100);
                console.log("CORE Writer's App Initialized");
            }

            initializeApp();
        });
    </script>
</body>
</html>
