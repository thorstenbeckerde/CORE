<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CHORUS Note Mapping for Writers</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400..700;1,400..700&family=Lato:wght@400;700&family=Special+Elite&display=swap" rel="stylesheet">
    <style>
        /* --- KEYFRAMES FOR ANIMATIONS --- */
        @keyframes pulseGlow {
            0%,
            100% {
                box-shadow: 0 0 10px 2px var(--color-primary);
                opacity: 0.6;
            }
            50% {
                box-shadow: 0 0 20px 8px var(--color-primary);
                opacity: 0.8;
            }
        }

        /* --- THEME AND FONT DEFINITIONS --- */
        :root {
            /* Font Variables */
            --font-display: 'Lora',
            serif;
            --font-sans: 'Lato',
            sans-serif;
            /* Default Theme: Sepia */
            --color-bg-main: #fbfaf5;
            --color-bg-toolbar: #f1ede7;
            --color-bg-modal: #f8f6f2;
            --color-bg-chunk: #ffffff;
            --color-bg-input: #ffffff;
            --color-text-main: #5c5248;
            --color-text-light: #8a7d70;
            --color-text-heading: #4a4137;
            --color-text-inverted: #ffffff;
            --color-border: #dcd3c9;
            --color-shadow: rgba(74, 65, 55, 0.1);
            --color-grid: #e0d8ce;
            --color-primary: #5a7a99;
            --color-primary-hover: #4b6680;
            --color-secondary: #dcd3c9;
            --color-secondary-hover: #c9bfae;
            --color-danger: #c55a5a;
            --color-danger-hover: #a54b4b;
            --color-donate: #5a9973;
            --color-donate-hover: #4b8061;
            --color-link-chunk: #5a7a99;
            --color-link-arrow: #5a7a99;
            --color-link-active: #5a9973;
            --color-chunk-selected: #5a7a99;
        }

        [data-theme="dark"] {
            --color-bg-main: #1f2328;
            --color-bg-toolbar: #1a1d21;
            --color-bg-modal: #282c32;
            --color-bg-chunk: #2c3137;
            --color-bg-input: #1f2328;
            --color-text-main: #c4c8cc;
            --color-text-light: #818a96;
            --color-text-heading: #e1e5e9;
            --color-text-inverted: #1f2328;
            --color-border: #404852;
            --color-shadow: rgba(0, 0, 0, 0.2);
            --color-grid: #3a414a;
            --color-primary: #5c8cae;
            --color-primary-hover: #72a2c9;
            --color-secondary: #404852;
            --color-secondary-hover: #525c68;
            --color-danger: #d96464;
            --color-danger-hover: #e87878;
            --color-donate: #5cae8c;
            --color-donate-hover: #72c9a2;
            --color-link-chunk: #5c8cae;
            --color-link-arrow: #5c8cae;
            --color-link-active: #5cae8c;
            --color-chunk-selected: #5c8cae;
        }

        [data-theme="ballpoint"] {
            --font-display: 'Lora',
            serif;
            --font-sans: 'Lato',
            sans-serif;
            --color-bg-main: #fdfdfd;
            --color-bg-toolbar: #eef2f7;
            --color-bg-modal: #f8f9fa;
            --color-bg-chunk: #ffffff;
            --color-bg-input: #ffffff;
            --color-text-main: #003366;
            /* Dark Blue Ink */
            --color-text-light: #5a7a99;
            --color-text-heading: #002244;
            --color-text-inverted: #ffffff;
            --color-border: #cdd8e3;
            --color-shadow: rgba(0, 51, 102, 0.1);
            --color-grid: #dce4ed;
            /* Light blue grid lines */
            --color-primary: #0055aa;
            --color-primary-hover: #004488;
            --color-secondary: #eef2f7;
            --color-secondary-hover: #dce4ed;
            --color-danger: #d9534f;
            --color-danger-hover: #c9302c;
            --color-donate: #5cb85c;
            --color-donate-hover: #4cae4c;
            --color-link-chunk: #0055aa;
            --color-link-arrow: #0055aa;
            --color-link-active: #5cb85c;
            --color-chunk-selected: #0055aa;
        }

        [data-theme="typewriter"] {
            --font-display: 'Special Elite',
            monospace;
            --font-sans: 'Special Elite',
            monospace;
            --color-bg-main: #f5f1e8;
            /* Aged paper */
            --color-bg-toolbar: #e8e2d7;
            --color-bg-modal: #f2ede4;
            --color-bg-chunk: #fcf8f0;
            --color-bg-input: #fcf8f0;
            --color-text-main: #333333;
            /* Faded black ink */
            --color-text-light: #777777;
            --color-text-heading: #1a1a1a;
            --color-text-inverted: #ffffff;
            --color-border: #dcd3c9;
            --color-shadow: rgba(51, 51, 51, 0.1);
            --color-grid: #e0d8ce;
            --color-primary: #b33a3a;
            /* Typewriter red */
            --color-primary-hover: #993131;
            --color-secondary: #e8e2d7;
            --color-secondary-hover: #dcd3c9;
            --color-danger: #b33a3a;
            --color-danger-hover: #993131;
            --color-donate: #5a9973;
            --color-donate-hover: #4b8061;
            --color-link-chunk: #666666;
            --color-link-arrow: #666666;
            --color-link-active: #b33a3a;
            --color-chunk-selected: #b33a3a;
        }

        [data-theme="typewriter"] .chunk-content,
        [data-theme="typewriter"] .btn {
            font-family: 'Special Elite',
            monospace;
        }

        [data-theme="poetry"] {
            --font-display: 'Lora',
            serif;
            --font-sans: 'Lato',
            sans-serif;
            --color-bg-main: #fbf9f6;
            /* Warmer off-white */
            --color-bg-toolbar: #f5efea;
            --color-bg-modal: #faf6f1;
            --color-bg-chunk: #ffffff;
            --color-bg-input: #ffffff;
            --color-text-main: #5d534a;
            /* Soft, dark brown */
            --color-text-light: #8c7f76;
            --color-text-heading: #4a4137;
            /* Darker brown */
            --color-text-inverted: #ffffff;
            --color-border: #e4dcd3;
            --color-shadow: rgba(89, 83, 74, 0.1);
            --color-grid: #e9e4de;
            --color-primary: #c89a9a;
            /* Dusty Rose */
            --color-primary-hover: #b48484;
            --color-secondary: #f5efea;
            --color-secondary-hover: #e9e2da;
            --color-danger: #c58c8c;
            --color-danger-hover: #a57474;
            --color-donate: #8a9a8c;
            /* Sage Green */
            --color-donate-hover: #758577;
            --color-link-chunk: #c89a9a;
            --color-link-arrow: #c89a9a;
            --color-link-active: #8a9a8c;
            --color-chunk-selected: #c89a9a;
        }

        /* --- BASE STYLES --- */
        body {
            font-family: var(--font-sans);
            background-color: var(--color-bg-main);
            color: var(--color-text-main);
            overscroll-behavior: none;
            overflow: hidden;
            transition: background-color 0.3s,
            color 0.3s;
        }

        #appContainer {
            width: 100vw;
            height: 100dvh;
            display: flex;
            flex-direction: column;
        }

        /* --- CANVAS & GRID --- */
        #noteCanvasContainer {
            position: relative;
            flex-grow: 1;
            overflow: hidden;
            background-color: var(--color-bg-main);
            cursor: grab;
            touch-action: none;
            background-image: linear-gradient(var(--color-grid) 1px, transparent 1px),
            linear-gradient(to right, var(--color-grid) 1px, transparent 1px);
            background-size: 50px 50px;
            transition: background-color 0.3s;
        }

        #noteCanvasContainer.grid-hidden {
            background-image: none;
        }

        #noteCanvasContainer:focus {
            outline: none;
        }

        #noteCanvasContainer.panning {
            cursor: grabbing;
        }

        #transformContainer {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
        }

        #noteCanvas {
            width: 8000px;
            /* Increased canvas size */
            height: 6000px;
            /* Increased canvas size */
            position: relative;
        }

        /* --- CENTER MARKER --- */
        #centerMarker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            transform: translate(-50%, -50%) scale(calc(1 / var(--scale, 1)));
            pointer-events: none;
            z-index: 0;
            transition: opacity 0.3s;
            will-change: transform;
            border-radius: 50%;
            --color-primary: #FACC15;
            /* Tailwind yellow-400 */
            animation: pulseGlow 4s infinite ease-in-out;
        }

        #centerMarker::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--color-primary);
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M12 2l2.54 7.82h8.21l-6.64 4.82 2.54 7.82L12 17.64l-6.65 4.82 2.54-7.82L1.25 9.82h8.21L12 2z'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M12 2l2.54 7.82h8.21l-6.64 4.82 2.54 7.82L12 17.64l-6.65 4.82 2.54-7.82L1.25 9.82h8.21L12 2z'/%3E%3C/svg%3E");
            -webkit-mask-size: contain;
            mask-size: contain;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            -webkit-mask-position: center;
            mask-position: center;
        }

        #centerMarker.hidden {
            opacity: 0;
        }

        /* --- CHUNK STYLES --- */
        #svgCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .chorus-chunk {
            position: absolute;
            background-color: var(--color-bg-chunk);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            box-shadow: 0 3px 5px var(--color-shadow),
            0 1px 2px var(--color-shadow);
            min-width: 200px;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            overflow: visible;
            transition: border-color 0.2s,
            outline 0.2s,
            background-color 0.3s,
            border-color 0.3s;
            z-index: 1;
        }

        .chorus-chunk.selected-chunk {
            border-color: var(--color-chunk-selected);
            border-width: 2px;
        }

        .chorus-chunk.linking-source-chunk {
            outline: 2px solid var(--color-link-active);
            border-color: var(--color-link-active);
        }

        .chunk-header {
            background-color: var(--color-bg-toolbar);
            padding: 6px 10px;
            font-size: 0.75rem;
            font-weight: 400;
            cursor: move;
            border-bottom: 1px solid var(--color-border);
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            touch-action: none;
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
            color: var(--color-text-light);
            transition: background-color 0.3s,
            border-color 0.3s;
            overflow: hidden;
            /* Add overflow hidden to the parent flex container */
        }

        .chunk-header-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
            /* Allow title to shrink */
        }

        .chunk-header-title .tag {
            font-family: var(--font-display);
            font-style: italic;
            font-weight: 600;
            color: var(--color-text-main);
        }

        .chunk-header-title .shape-symbol,
        .chunk-header-title .color-symbol {
            font-weight: normal;
        }

        .chunk-content {
            flex-grow: 1;
            padding: 12px;
            font-size: 0.95rem;
            line-height: 1.6;
            overflow-y: auto;
            outline: none;
        }

        .resize-handle {
            width: 16px;
            height: 16px;
            position: absolute;
            right: -4px;
            bottom: -4px;
            cursor: se-resize;
            touch-action: none;
            z-index: 10;
        }

        .resize-handle::after {
            content: '';
            position: absolute;
            width: 10px;
            height: 10px;
            right: 2px;
            bottom: 2px;
            border-bottom: 2px solid var(--color-text-light);
            border-right: 2px solid var(--color-text-light);
            opacity: 0.5;
            border-bottom-right-radius: 2px;
        }

        /* --- TOOLBAR, BUTTONS, FORMS --- */
        .toolbar {
            background-color: var(--color-bg-toolbar);
            box-shadow: 0 1px 3px var(--color-shadow);
            transition: background-color 0.3s;
            z-index: 100;
        }

        h2,
        h3 {
            font-family: var(--font-display);
            font-weight: 600;
            color: var(--color-text-heading);
        }

        .btn {
            padding: 8px 14px;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s,
            color 0.2s,
            opacity 0.2s,
            transform 0.1s;
            border: 1px solid transparent;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 0.05em;
        }

        .btn:active:not(:disabled) {
            transform: translateY(1px);
        }

        .btn svg.icon {
            width: 16px;
            height: 16px;
            margin-right: 8px;
        }

        .btn svg.spinner {
            width: 18px;
            height: 18px;
            margin: auto;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: var(--color-text-inverted);
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--color-primary-hover);
        }

        .btn-secondary {
            background-color: var(--color-secondary);
            color: var(--color-text-main);
            border-color: var(--color-border);
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: var(--color-secondary-hover);
        }

        .btn-danger {
            background-color: var(--color-danger);
            color: var(--color-text-inverted);
        }

        .btn-danger:hover:not(:disabled) {
            background-color: var(--color-danger-hover);
        }

        .btn-donate {
            background-color: var(--color-donate);
            color: var(--color-text-inverted);
        }

        .btn-donate:hover:not(:disabled) {
            background-color: var(--color-donate-hover);
        }

        .form-input,
        .form-textarea,
        .form-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            margin-bottom: 12px;
            background-color: var(--color-bg-input);
            color: var(--color-text-main);
            transition: background-color 0.3s,
            border-color 0.3s;
        }

        /* --- MODAL STYLES --- */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .modal-content {
            background-color: var(--color-bg-modal);
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 550px;
            border: 1px solid var(--color-border);
            transition: background-color 0.3s,
            border-color 0.3s;
        }

        #helpModal .modal-content,
        #messageModal .modal-content {
            display: flex;
            flex-direction: column;
            max-height: 80vh;
        }

        #help-scroll-content,
        #messageText {
            max-height: 60vh;
            overflow-y: auto;
            line-height: 1.7;
        }

        #help-scroll-content h3 {
            font-family: var(--font-display);
            font-weight: 700;
            color: var(--color-text-heading);
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        #help-scroll-content p,
        #help-scroll-content ul {
            margin-bottom: 0.75rem;
        }

        #help-scroll-content ul {
            list-style-position: inside;
            padding-left: 1rem;
        }

        #help-scroll-content code {
            background-color: var(--color-bg-toolbar);
            padding: 2px 5px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.85rem;
        }

        .close-button {
            color: var(--color-text-light);
            float: right;
            font-size: 28px;
            font-weight: bold;
            line-height: 1;
        }

        .close-button:hover,
        .close-button:focus {
            color: var(--color-text-main);
            text-decoration: none;
            cursor: pointer;
        }

        /* --- LINKING & SVG STYLES --- */
        .connecting-line {
            stroke: var(--color-link-chunk);
            stroke-width: 2;
            fill: none;
            transition: stroke 0.3s;
        }

        .arrow-head {
            fill: var(--color-link-arrow);
            transition: fill 0.3s;
        }

        body.linking-mode {
            cursor: crosshair;
        }

        body.linking-mode .chorus-chunk:not(.linking-source-chunk):hover {
            outline: 2px dashed var(--color-chunk-selected);
        }

        .link-chunk-btn.linking-active svg {
            stroke: var(--color-link-active) !important;
        }

        /* --- MISC --- */
        footer {
            background-color: var(--color-bg-toolbar);
            transition: background-color 0.3s;
        }

        .chunk-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px;
            margin-left: 4px;
            line-height: 1;
        }

        .chunk-actions {
            flex-shrink: 0;
            /* Prevent the actions container from shrinking */
            padding-left: 8px;
            /* Ensure space between title and buttons */
        }

        .chunk-action-btn svg {
            stroke: var(--color-text-light);
            width: 14px;
            height: 14px;
        }

        .chunk-action-btn:hover svg {
            stroke: var(--color-text-main);
        }

        .delete-chunk-btn:hover svg {
            stroke: var(--color-danger) !important;
        }

        .ai-chunk-btn:hover svg {
            stroke: #8b5cf6 !important;
        }
    </style>
</head>

<body>
    <div id="appContainer">
        <div class="toolbar p-3 shadow-md flex flex-wrap items-center justify-center sm:justify-between gap-x-4 gap-y-2 print:hidden">
            <div class="flex items-center flex-wrap justify-center gap-2">
                <button id="addChunkBtn" class="btn btn-primary" title="Add Chunk (A)">Add</button>
                <button id="shuffleChunksBtn" class="btn btn-secondary" title="Shuffle Chunks">Shuffle</button>
                <button id="clearCanvasBtn" class="btn btn-danger" title="Clear Canvas">Clear</button>
                <button id="undoDeleteBtn" class="btn btn-secondary" title="Undo Last Delete (Ctrl/Cmd+Z)" disabled>Undo</button>
            </div>

            <div class="flex items-center flex-wrap justify-center gap-2">
                <button id="zoomOutBtn" class="btn btn-secondary" title="Zoom Out (-)">-</button>
                <button id="zoomResetBtn" class="btn btn-secondary" title="Reset Zoom (0)">100%</button>
                <button id="centerLastBtn" class="btn btn-secondary" title="Center on Last Added Chunk (C)" disabled>Center</button>
                <button id="zoomInBtn" class="btn btn-secondary" title="Zoom In (+/=)">+</button>
            </div>

            <div class="flex items-center flex-wrap justify-center gap-2">
                <button id="summarizeBtn" class="btn btn-secondary" title="Summarize the board with AI">
                    Summarize
                </button>
                <span id="chunkCountDisplay" class="text-sm text-gray-500 mx-2">Chunks: 0</span>
                <button id="saveBtn" class="btn btn-secondary" title="Save to File (Ctrl/Cmd+S)">Save</button>
                <button id="loadBtn" class="btn btn-secondary" title="Load from File (Ctrl/Cmd+O)">Load</button>
                <div class="relative inline-block text-left">
                    <button id="exportBtn" class="btn btn-secondary" title="Export Options">Export</button>
                    <div id="exportDropdown" class="absolute right-0 mt-2 w-40 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 hidden">
                        <div class="py-1" role="menu"><button id="exportTxtBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">TXT</button><button id="exportHtmlBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">HTML</button><button id="exportMdBtn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">MD</button></div>
                    </div>
                </div>
                <button id="settingsBtn" class="btn btn-secondary" title="Settings">Settings</button>
                <button id="helpBtn" class="btn btn-secondary" title="Help (?)">Help</button>
                <button id="donateBtn" class="btn btn-donate" title="Support the Project">Donate</button>
            </div>
        </div>

        <div id="noteCanvasContainer" tabindex="-1">
            <div id="transformContainer">
                <div id="noteCanvas">
                    <svg id="svgCanvas"></svg>
                    <div id="centerMarker" class="hidden"></div>
                </div>
            </div>
        </div>
    </div>

    <footer class="text-center p-2 text-xs text-gray-500 print:hidden">
        &copy; <span id="copyrightYear"></span> Thorsten Becker, <a href="https://www.thorstenbecker.de" target="_blank" class="text-blue-600 hover:underline">thorstenbecker.de</a>.
    </footer>

    <div id="addChunkModal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-xl mb-4">Add New Chunk</h2> <label for="chunkTypeSelect" class="block mb-1 font-medium">Chunk Type:</label> <select id="chunkTypeSelect" class="form-select"></select> <label for="chunkShapeSelect" class="block mb-1 mt-3 font-medium">Shape:</label> <select id="chunkShapeSelect" class="form-select"></select> <label for="chunkColorSelect" class="block mb-1 mt-3 font-medium">Color Tag:</label> <select id="chunkColorSelect" class="form-select"></select>
            <div class="mt-6 flex justify-end"> <button id="cancelAddChunkBtn" class="btn btn-secondary">Cancel</button> <button id="confirmAddChunkBtn" class="btn btn-primary">Add Chunk</button> </div>
        </div>
    </div>
    <div id="editChunkModal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-xl mb-4">Edit Chunk</h2> <input type="hidden" id="editingChunkId"> <label for="editChunkTypeSelect" class="block mb-1 font-medium">Chunk Type:</label> <select id="editChunkTypeSelect" class="form-select"></select> <label for="editChunkShapeSelect" class="block mb-1 mt-3 font-medium">Shape:</label> <select id="editChunkShapeSelect" class="form-select"></select> <label for="editChunkColorSelect" class="block mb-1 mt-3 font-medium">Color Tag:</label> <select id="editChunkColorSelect" class="form-select"></select>
            <div class="mt-6 flex justify-end"> <button id="cancelEditChunkBtn" class="btn btn-secondary">Cancel</button> <button id="confirmEditChunkBtn" class="btn btn-primary">Save Changes</button> </div>
        </div>
    </div>
    <div id="aiActionModal" class="modal hidden">
        <div class="modal-content"> <span id="closeAiActionModalBtn" class="close-button">&times;</span>
            <h2 class="flex items-center text-xl mb-4">AI Assistant</h2>
            <p class="text-sm text-gray-600 mb-4">Powered by Gemini. Current chunk content will be used as context.</p> <label for="aiPromptTextarea" class="block mb-1 mt-3 font-medium">Your Prompt:</label> <textarea id="aiPromptTextarea" class="form-textarea" placeholder="e.g., 'Rewrite this to be more concise.'"></textarea>
            <div class="mt-4 flex flex-wrap justify-between items-center gap-2"> <button id="aiActionSuggestNextBtn" class="btn btn-secondary">Suggest Next</button>
                <div class="flex-grow"></div> <button id="cancelAiActionBtn" class="btn btn-secondary">Cancel</button> <button id="aiActionGenerateBtn" class="btn btn-primary">Generate & Replace</button>
            </div>
        </div>
    </div>
    <div id="messageModal" class="modal hidden">
        <div class="modal-content max-w-lg">
            <h2 id="messageTitle" class="text-xl font-semibold mb-3">Message</h2>
            <div id="messageText" class="mb-4 text-sm"></div>
            <div id="messageButtons" class="flex justify-end gap-3"></div>
        </div>
    </div>

    <div id="settingsModal" class="modal hidden">
        <div class="modal-content">
            <span id="closeSettingsModalBtn" class="close-button">&times;</span>
            <h2 class="text-xl mb-6">Settings</h2>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                <div>
                    <label for="themeSelect" class="block mb-2 font-medium">Theme</label>
                    <select id="themeSelect" class="form-select">
                        <option value="sepia">Sepia</option>
                        <option value="dark">Dark</option>
                        <option value="ballpoint">Ballpoint</option>
                        <option value="typewriter">Typewriter</option>
                        <option value="poetry">Poetry</option>
                    </select>
                </div>
                <div class="flex flex-col justify-end">
                    <div class="flex items-center space-x-8">
                        <label for="gridToggle" class="flex items-center cursor-pointer">
                            <input type="checkbox" id="gridToggle" class="form-input h-5 w-5 mr-3">
                            <span class="font-medium">Show Grid</span>
                        </label>
                        <label for="centerMarkerToggle" class="flex items-center cursor-pointer">
                            <input type="checkbox" id="centerMarkerToggle" class="form-input h-5 w-5 mr-3">
                            <span class="font-medium">Show Center Marker</span>
                        </label>
                    </div>
                </div>
            </div>

            <hr class="border-t border-border my-6">

            <label for="geminiApiKeyInput" class="block mb-1 font-medium">Google AI API Key</label>
            <p class="text-xs text-text-light mb-2">Required for AI features. Your key is saved only in your browser.</p>
            <input type="password" id="geminiApiKeyInput" class="form-input" placeholder="Enter your API key here">
            <p class="text-xs text-text-light mb-4">Get a key from <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-[var(--color-primary)] hover:underline">Google AI Studio</a>.</p>

            <div class="mt-6 flex justify-end">
                <button id="cancelSettingsBtn" class="btn btn-secondary">Cancel</button>
                <button id="saveSettingsBtn" class="btn btn-primary">Save Settings</button>
            </div>
        </div>
    </div>

    <div id="helpModal" class="modal hidden">
        <div class="modal-content">
            <span id="closeHelpModalSpan" class="close-button">&times;</span>
            <h2 class="text-2xl mb-4">CHORUS Quick Help</h2>
            <div id="help-scroll-content">
            </div>
            <div class="mt-6 flex justify-end"><button id="closeHelpBtn" class="btn btn-primary">OK</button></div>
        </div>
    </div>
    
    <!-- Session Restore Modal -->
    <div id="sessionRestoreModal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-xl mb-4">Welcome Back!</h2>
            <p class="mb-6 text-text-main">
                We've restored your last session from a secure, local browser save.
                You can continue where you left off, or start with a fresh, blank canvas.
            </p>
            <div class="flex justify-end gap-3">
                <button id="startFreshBtn" class="btn btn-secondary">Start Fresh</button>
                <button id="continueSessionBtn" class="btn btn-primary">Continue</button>
            </div>
        </div>
    </div>

    <input type="file" id="fileLoadInput" class="hidden" accept=".json,application/json">

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Constants and App Config ---
            const CHUNK_TYPES = {
                core: [{
                    tag: "#central",
                    description: "The seed thought, core concept"
                }, {
                    tag: "#essential",
                    description: "Key supporting points or moments"
                }, {
                    tag: "#expanded",
                    description: "Deeper exploration, examples, nuance"
                }, {
                    tag: "#supportive",
                    description: "Details, quotes, sensory notes"
                }, {
                    tag: "#transition",
                    description: "Bridge between sections or ideas"
                }, {
                    tag: "#loopback",
                    description: "Refers to another chunk, prior note, or core concept"
                }, {
                    tag: "#conclusive",
                    description: "Ending remarks, reflection, resolution"
                }],
                optional: [{
                    tag: "#contextual",
                    description: "Background information, historical context, or literature review content"
                }, {
                    tag: "#counterpoint",
                    description: "Opposing viewpoints, limitations, or challenges to the central idea"
                }, {
                    tag: "#application",
                    description: "Practical implications, 'how-to' elements, or real-world relevance"
                }],
                narrative: [{
                    tag: "#temporal",
                    description: "Indicates a passage of time (e.g., 'Later that eveningâ€¦')"
                }, {
                    tag: "#spatial",
                    description: "Marks a location change (e.g., 'Across the cityâ€¦')"
                }, {
                    tag: "#spatiotemporal",
                    description: "Combines time and location shift (e.g., 'Meanwhile, in Tokyoâ€¦')"
                }, {
                    tag: "#flashback",
                    description: "Indicates a past event or memory outside the main timeline"
                }],
                conceptual: [{
                    tag: "#dreamlike",
                    description: "Marks dream sequences, hallucinations, or altered states"
                }, {
                    tag: "#perspective",
                    description: "Indicates a shift in point of view or narrative lens"
                }]
            };
            const ALL_CHUNK_TYPES = Object.values(CHUNK_TYPES).flat();
            const SHAPES = [{
                name: "Circle",
                symbol: "â—¯",
                meaning: "Core, self, central focus, inner truth"
            }, {
                name: "Square",
                symbol: "â–¢",
                meaning: "Structure, foundation, argument"
            }, {
                name: "Diamond",
                symbol: "â—‡",
                meaning: "Insight, key moment, crystallization"
            }, {
                name: "Triangle",
                symbol: "â–³",
                meaning: "Change, direction, movement, shift"
            }, {
                name: "(Hook) Arrow",
                symbol: "â¤£",
                meaning: "Transition, liminality, unstable ground"
            }, {
                name: "Exclamation Mark",
                symbol: "!",
                meaning: "Emphasis, resonance, punctuation of thought"
            }, {
                name: "Vertical Bars",
                symbol: "â€–",
                meaning: "Parallel thought, holding apart, duality"
            }, {
                name: "Horizontal Bars",
                symbol: "=",
                meaning: "Harmony, balance, synthesis"
            }, {
                name: "Broken Bars",
                symbol: "â‰ ",
                meaning: "Opposition, negation, unresolved tension"
            }, {
                name: "Panel",
                symbol: "â–±",
                meaning: "Container, segment, scene"
            }];
            const COLORS = [{
                name: "Red",
                symbol: "ðŸ”´",
                essence: "Tension, urgency, conflict",
                tailwindClass: "text-red-500"
            }, {
                name: "Blue",
                symbol: "ðŸ”µ",
                essence: "Calm, stability, reflection",
                tailwindClass: "text-blue-500"
            }, {
                name: "Green",
                symbol: "ðŸŸ¢",
                essence: "Growth, potential, harmony",
                tailwindClass: "text-green-500"
            }, {
                name: "Yellow",
                symbol: "ðŸŸ¡",
                essence: "Curiosity, newness, clarity",
                tailwindClass: "text-yellow-400"
            }, {
                name: "Purple",
                symbol: "ðŸŸ£",
                essence: "Depth, mystery, inner insight",
                tailwindClass: "text-purple-500"
            }, {
                name: "Grey",
                symbol: "ðŸ©¶",
                essence: "Neutrality, logic, stepping back",
                tailwindClass: "text-gray-500"
            }, {
                name: "Black",
                symbol: "âš«",
                essence: "Finality, anchor, gravitas",
                tailwindClass: "text-black"
            }, {
                name: "White",
                symbol: "âšª",
                essence: "Openness, undefined, exploratory",
                tailwindClass: "text-gray-300"
            }];
            const ICON_PENCIL_EDIT = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" /></svg>`;
            const ICON_LINK = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" /></svg>`;
            const ICON_UNLINK = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244m-9.951-2.206a4.5 4.5 0 006.364-6.364L9.65 3.65m-3.069 3.069L3.5 9.787m0 0L1.454 7.742M3.5 9.787l2.046 2.046M3 3l18 18" /></svg>`;
            const ICON_LINKING_ACTIVE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="animate-pulse"><path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" /></svg>`;
            const ICON_DELETE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" /></svg>`;
            const ICON_AI_SPARKLE = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.25 10.5l-1.5-1.5 1.5-1.5 1.5 1.5-1.5 1.5ZM16.5 3.75l-1.5-1.5 1.5-1.5 1.5 1.5-1.5 1.5Z" /></svg>`;
            const MIN_SCALE = 0.1,
                MAX_SCALE = 3.0,
                ZOOM_SENSITIVITY = 0.001;
            const GRID_SIZE = 50;

            // --- DOM Elements Cache ---
            const DOMElements = {
                body: document.body,
                noteCanvasContainer: document.getElementById('noteCanvasContainer'),
                transformContainer: document.getElementById('transformContainer'),
                svgCanvas: document.getElementById('svgCanvas'),
                noteCanvas: document.getElementById('noteCanvas'),
                centerMarker: document.getElementById('centerMarker'),
                // Toolbar
                addChunkBtn: document.getElementById('addChunkBtn'),
                centerLastBtn: document.getElementById('centerLastBtn'),
                shuffleChunksBtn: document.getElementById('shuffleChunksBtn'),
                clearCanvasBtn: document.getElementById('clearCanvasBtn'),
                undoDeleteBtn: document.getElementById('undoDeleteBtn'),
                chunkCountDisplay: document.getElementById('chunkCountDisplay'),
                zoomInBtn: document.getElementById('zoomInBtn'),
                zoomOutBtn: document.getElementById('zoomOutBtn'),
                zoomResetBtn: document.getElementById('zoomResetBtn'),
                // Modals
                addChunkModal: document.getElementById('addChunkModal'),
                chunkTypeSelect: document.getElementById('chunkTypeSelect'),
                chunkShapeSelect: document.getElementById('chunkShapeSelect'),
                chunkColorSelect: document.getElementById('chunkColorSelect'),
                confirmAddChunkBtn: document.getElementById('confirmAddChunkBtn'),
                cancelAddChunkBtn: document.getElementById('cancelAddChunkBtn'),
                editChunkModal: document.getElementById('editChunkModal'),
                editingChunkIdInput: document.getElementById('editingChunkId'),
                editChunkTypeSelect: document.getElementById('editChunkTypeSelect'),
                editChunkShapeSelect: document.getElementById('editChunkShapeSelect'),
                editChunkColorSelect: document.getElementById('editChunkColorSelect'),
                confirmEditChunkBtn: document.getElementById('confirmEditChunkBtn'),
                cancelEditChunkBtn: document.getElementById('cancelEditChunkBtn'),
                summarizeBtn: document.getElementById('summarizeBtn'),
                // Settings & Help
                settingsBtn: document.getElementById('settingsBtn'),
                settingsModal: document.getElementById('settingsModal'),
                geminiApiKeyInput: document.getElementById('geminiApiKeyInput'),
                saveSettingsBtn: document.getElementById('saveSettingsBtn'),
                cancelSettingsBtn: document.getElementById('cancelSettingsBtn'),
                closeSettingsModalBtn: document.getElementById('closeSettingsModalBtn'),
                themeSelect: document.getElementById('themeSelect'),
                gridToggle: document.getElementById('gridToggle'),
                centerMarkerToggle: document.getElementById('centerMarkerToggle'),
                donateBtn: document.getElementById('donateBtn'),
                helpBtn: document.getElementById('helpBtn'),
                helpModal: document.getElementById('helpModal'),
                helpContent: document.getElementById('help-scroll-content'),
                closeHelpBtn: document.getElementById('closeHelpBtn'),
                closeHelpModalSpan: document.getElementById('closeHelpModalSpan'),
                // AI
                aiActionModal: document.getElementById('aiActionModal'),
                aiPromptTextarea: document.getElementById('aiPromptTextarea'),
                aiActionGenerateBtn: document.getElementById('aiActionGenerateBtn'),
                aiActionSuggestNextBtn: document.getElementById('aiActionSuggestNextBtn'),
                cancelAiActionBtn: document.getElementById('cancelAiActionBtn'),
                closeAiActionModalBtn: document.getElementById('closeAiActionModalBtn'),
                // I/O
                saveBtn: document.getElementById('saveBtn'),
                loadBtn: document.getElementById('loadBtn'),
                fileLoadInput: document.getElementById('fileLoadInput'),
                exportBtn: document.getElementById('exportBtn'),
                exportDropdown: document.getElementById('exportDropdown'),
                exportTxtBtn: document.getElementById('exportTxtBtn'),
                exportHtmlBtn: document.getElementById('exportHtmlBtn'),
                exportMdBtn: document.getElementById('exportMdBtn'),
                // Message
                messageModal: document.getElementById('messageModal'),
                messageTitle: document.getElementById('messageTitle'),
                messageText: document.getElementById('messageText'),
                messageButtons: document.getElementById('messageButtons'),
                // Session Restore
                sessionRestoreModal: document.getElementById('sessionRestoreModal'),
                continueSessionBtn: document.getElementById('continueSessionBtn'),
                startFreshBtn: document.getElementById('startFreshBtn'),
            };

            // --- App State ---
            let state = {
                chunks: [],
                chunksMap: new Map(),
                highestZIndex: 1,
                selectedChunkId: null,
                lastDeletedChunk: null,
                lastAddedChunkId: null,
                linkingMode: false,
                linkingSourceChunkId: null,
                geminiApiKey: null,
                activeAiChunkId: null,
                // Transform state
                scale: 1,
                translateX: 0,
                translateY: 0,
                // Interaction state
                currentAction: null,
                panStartX: 0,
                panStartY: 0,
                interactionStartX: 0,
                interactionStartY: 0,
                offsetX: 0,
                offsetY: 0,
                startWidth: 0,
                startHeight: 0,
                initialPinchDistance: null,
                transformUpdateQueued: false,
            };

            let originalTheme = 'sepia';

            // --- Utility Functions ---
            const generateId = () => 'chunk-' + Date.now() + '-' + Math.random().toString(36).substring(2, 9);
            const showModal = (modal) => modal.classList.remove('hidden');
            const hideModal = (modal) => modal.classList.add('hidden');

            function showMessage(title, text, buttonsConfig = [{
                text: 'OK',
                class: 'btn-primary',
                action: () => hideModal(DOMElements.messageModal)
            }]) {
                DOMElements.messageTitle.textContent = title;
                DOMElements.messageText.innerHTML = text;
                DOMElements.messageButtons.innerHTML = '';
                buttonsConfig.forEach(btnConfig => {
                    const button = document.createElement('button');
                    button.className = `btn ${btnConfig.class || 'btn-secondary'} m-1`;
                    button.textContent = btnConfig.text;
                    button.onclick = () => {
                        if (btnConfig.action) btnConfig.action();
                        if (!btnConfig.noHide) hideModal(DOMElements.messageModal);
                    };
                    DOMElements.messageButtons.appendChild(button);
                });
                showModal(DOMElements.messageModal);
            }

            // --- Auto-Save & Session Management ---
            const AUTO_SAVE_KEY = 'chorusAutoSave';
            let autoSaveTimeout;

            function triggerAutoSave() {
                // This function is the single point of entry for auto-saving.
                // It's debounced to prevent excessive writes to localStorage.
                clearTimeout(autoSaveTimeout);
                autoSaveTimeout = setTimeout(() => {
                    if (state.chunks.length === 0) {
                        // If the canvas is empty, clear the save as well.
                        clearAutoSave();
                    } else {
                        // Gather the current state and save it.
                        state.chunks.forEach(chunkData => {
                            const chunkElement = document.getElementById(chunkData.id);
                            if (chunkElement) {
                                const contentDiv = chunkElement.querySelector('.chunk-content');
                                if (contentDiv) {
                                    chunkData.text = contentDiv.innerHTML;
                                }
                            }
                        });
                        const dataToSave = {
                            chunks: state.chunks,
                            viewport: {
                                scale: state.scale,
                                translateX: state.translateX,
                                translateY: state.translateY
                            },
                            lastAddedChunkId: state.lastAddedChunkId,
                            highestZIndex: state.highestZIndex,
                            lastDeletedChunk: state.lastDeletedChunk // Also save the last deleted chunk for undo persistence
                        };
                        localStorage.setItem(AUTO_SAVE_KEY, JSON.stringify(dataToSave));
                        // console.log("Session auto-saved."); // Optional: for debugging
                    }
                }, 1000); // Save 1 second after the last change.
            }

            function clearAutoSave() {
                localStorage.removeItem(AUTO_SAVE_KEY);
                console.log("Auto-save data cleared.");
            }

            function loadSessionFromAutoSave() {
                const savedDataJSON = localStorage.getItem(AUTO_SAVE_KEY);
                if (savedDataJSON) {
                    try {
                        const savedData = JSON.parse(savedDataJSON);
                        if (savedData && Array.isArray(savedData.chunks) && savedData.chunks.length > 0) {
                            // Load data into state but don't render yet
                            state.chunks = savedData.chunks;
                            if (savedData.viewport) {
                                state.scale = savedData.viewport.scale || 1;
                                state.translateX = savedData.viewport.translateX || 0;
                                state.translateY = savedData.viewport.translateY || 0;
                            }
                            state.lastAddedChunkId = savedData.lastAddedChunkId || null;
                            state.highestZIndex = savedData.highestZIndex || 1;
                            state.lastDeletedChunk = savedData.lastDeletedChunk || null;


                            // Now show the modal
                            showModal(DOMElements.sessionRestoreModal);
                            return true; // Indicate that a session was found
                        }
                    } catch (e) {
                        console.error("Error parsing auto-saved session data:", e);
                        clearAutoSave(); // Clear corrupted data
                    }
                }
                return false; // No session found
            }

            // --- Settings & Preferences ---
            function applyTheme(themeName) {
                DOMElements.body.dataset.theme = themeName;
            }

            function toggleGridVisibility(isVisible) {
                DOMElements.noteCanvasContainer.classList.toggle('grid-hidden', !isVisible);
            }

            function toggleCenterMarkerVisibility(isVisible) {
                DOMElements.centerMarker.classList.toggle('hidden', !isVisible);
            }

            function loadSettings() {
                // API Key
                const key = localStorage.getItem('geminiApiKey');
                if (key) {
                    state.geminiApiKey = key;
                    DOMElements.geminiApiKeyInput.value = key;
                }
                // Theme
                const theme = localStorage.getItem('chorusTheme') || 'sepia';
                DOMElements.themeSelect.value = theme;
                applyTheme(theme);
                originalTheme = theme;
                // Grid
                const isGridVisible = localStorage.getItem('chorusGridVisible') !== 'false';
                DOMElements.gridToggle.checked = isGridVisible;
                toggleGridVisibility(isGridVisible);
                // Center Marker
                const isMarkerVisible = localStorage.getItem('chorusMarkerVisible') === 'true';
                DOMElements.centerMarkerToggle.checked = isMarkerVisible;
                toggleCenterMarkerVisibility(isMarkerVisible);
            }

            function saveSettings() {
                // API Key
                const key = DOMElements.geminiApiKeyInput.value.trim();
                if (key) {
                    state.geminiApiKey = key;
                    localStorage.setItem('geminiApiKey', key);
                } else {
                    state.geminiApiKey = null;
                    localStorage.removeItem('geminiApiKey');
                }
                // Theme
                const theme = DOMElements.themeSelect.value;
                localStorage.setItem('chorusTheme', theme);
                applyTheme(theme);
                originalTheme = theme;
                // Grid
                const isGridVisible = DOMElements.gridToggle.checked;
                localStorage.setItem('chorusGridVisible', isGridVisible);
                toggleGridVisibility(isGridVisible);
                // Center Marker
                const isMarkerVisible = DOMElements.centerMarkerToggle.checked;
                localStorage.setItem('chorusMarkerVisible', isMarkerVisible);
                toggleCenterMarkerVisibility(isMarkerVisible);

                showMessage("Settings Saved", "Your preferences have been updated.");
                hideModal(DOMElements.settingsModal);
            }

            function cancelSettings() {
                applyTheme(originalTheme);
                DOMElements.themeSelect.value = originalTheme;
                hideModal(DOMElements.settingsModal);
            }

            // --- Transform and Coordinate Functions ---
            function applyTransform() {
                if (state.transformUpdateQueued) return;
                state.transformUpdateQueued = true;
                requestAnimationFrame(() => {
                    DOMElements.transformContainer.style.transform = `translate(${state.translateX}px, ${state.translateY}px) scale(${state.scale})`;

                    DOMElements.noteCanvasContainer.style.setProperty('--scale', state.scale);

                    const bgPosX = state.translateX % (GRID_SIZE * state.scale);
                    const bgPosY = state.translateY % (GRID_SIZE * state.scale);
                    DOMElements.noteCanvasContainer.style.backgroundPosition = `${bgPosX}px ${bgPosY}px`;
                    DOMElements.noteCanvasContainer.style.backgroundSize = `${GRID_SIZE * state.scale}px ${GRID_SIZE * state.scale}px`;

                    DOMElements.svgCanvas.setAttribute('width', String(DOMElements.noteCanvas.scrollWidth));
                    DOMElements.svgCanvas.setAttribute('height', String(DOMElements.noteCanvas.scrollHeight));
                    drawConnections();
                    state.transformUpdateQueued = false;
                });
            }

            function screenToWorld(screenX, screenY) {
                const containerRect = DOMElements.noteCanvasContainer.getBoundingClientRect();
                const worldX = (screenX - containerRect.left - state.translateX) / state.scale;
                const worldY = (screenY - containerRect.top - state.translateY) / state.scale;
                return {
                    x: worldX,
                    y: worldY
                };
            }

            function centerOnChunk(chunkId) {
                const chunkData = state.chunksMap.get(chunkId);
                if (!chunkData) return;

                const viewportWidth = DOMElements.noteCanvasContainer.clientWidth;
                const viewportHeight = DOMElements.noteCanvasContainer.clientHeight;

                const newScale = 1.0;
                state.scale = newScale;

                const chunkCenterX = chunkData.x + chunkData.width / 2;
                const chunkCenterY = chunkData.y + chunkData.height / 2;

                state.translateX = viewportWidth / 2 - chunkCenterX * newScale;
                state.translateY = viewportHeight / 2 - chunkCenterY * newScale;

                applyTransform();
                triggerAutoSave();
            }


            function resetAndCenterView() {
                state.scale = 1;
                const viewportWidth = DOMElements.noteCanvasContainer.clientWidth;
                const viewportHeight = DOMElements.noteCanvasContainer.clientHeight;
                const canvasContentWidth = DOMElements.noteCanvas.scrollWidth;
                const canvasContentHeight = DOMElements.noteCanvas.scrollHeight;
                state.translateX = (viewportWidth - canvasContentWidth * state.scale) / 2;
                state.translateY = (viewportHeight - canvasContentHeight * state.scale) / 2;
                applyTransform();
                triggerAutoSave();
            }

            // --- Board Rendering ---
            function renderBoard(loadedChunksData) {
                DOMElements.noteCanvas.querySelectorAll('.chorus-chunk').forEach(el => el.remove());
                DOMElements.svgCanvas.innerHTML = '';
                svgDefsCreated = false;

                state.chunks = loadedChunksData || [];
                state.chunksMap.clear();
                state.highestZIndex = state.highestZIndex || 0;
                state.selectedChunkId = null;
                // Don't clear lastDeletedChunk here, it might be restored
                DOMElements.undoDeleteBtn.disabled = !state.lastDeletedChunk;
                DOMElements.centerLastBtn.disabled = !state.lastAddedChunkId;
                cancelLinkingMode(true);

                if (Array.isArray(state.chunks)) {
                    state.chunks.forEach(chunkData => {
                        if (chunkData && chunkData.id) {
                            state.chunksMap.set(chunkData.id, chunkData);
                            createChunkElement(chunkData);
                            if (chunkData.zIndex > state.highestZIndex) {
                                state.highestZIndex = chunkData.zIndex;
                            }
                        }
                    });
                }
                if (state.chunks.length === 0) {
                    state.highestZIndex = 1;
                    state.lastAddedChunkId = null;
                    DOMElements.centerLastBtn.disabled = true;
                }

                updateSelectedVisuals();
                drawConnections();
                updateChunkCounter();
                triggerAutoSave();
            }

            // --- Chunk Management ---
            function addChunkToCanvas(chunkDetails, options = {}) {
                const viewportRect = DOMElements.noteCanvasContainer.getBoundingClientRect();
                const defaultWorldPos = screenToWorld(viewportRect.left + viewportRect.width / 2, viewportRect.top + viewportRect.height / 4);

                const newChunkData = {
                    id: generateId(),
                    chunkTypeTag: chunkDetails.type.tag,
                    shapeName: chunkDetails.shape.name,
                    colorName: chunkDetails.color.name,
                    text: options.text || '<p>New chunk... Start typing!</p>',
                    x: options.x !== undefined ? options.x : Math.max(0, defaultWorldPos.x - 125),
                    y: options.y !== undefined ? options.y : Math.max(0, defaultWorldPos.y - 75),
                    width: 250,
                    height: 150,
                    zIndex: ++state.highestZIndex,
                    nextChunkId: null
                };

                state.chunks.push(newChunkData);
                state.chunksMap.set(newChunkData.id, newChunkData);
                createChunkElement(newChunkData);
                selectChunk(newChunkData.id);
                state.lastAddedChunkId = newChunkData.id;
                DOMElements.centerLastBtn.disabled = false;

                drawConnections();
                updateChunkCounter();
                triggerAutoSave();
                return newChunkData;
            }

            function createChunkElement(chunkData) {
                const chunkDiv = document.createElement('div');
                chunkDiv.id = chunkData.id;
                chunkDiv.className = 'chorus-chunk';
                chunkDiv.style.left = chunkData.x + 'px';
                chunkDiv.style.top = chunkData.y + 'px';
                chunkDiv.style.width = chunkData.width + 'px';
                chunkDiv.style.height = chunkData.height + 'px';
                chunkDiv.style.zIndex = String(chunkData.zIndex);

                const header = document.createElement('div');
                header.className = 'chunk-header';

                const headerTitle = document.createElement('span');
                headerTitle.className = 'chunk-header-title';

                const actionsContainer = document.createElement('div');
                actionsContainer.className = 'chunk-actions flex items-center';

                const createActionButton = (className, title, icon, handler) => {
                    const btn = document.createElement('button');
                    btn.className = `chunk-action-btn ${className}`;
                    btn.title = title;
                    btn.innerHTML = icon;
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        handler(e);
                    });
                    btn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        handler(e);
                    });
                    return btn;
                };

                const aiBtn = createActionButton('ai-chunk-btn', 'AI Assistant', ICON_AI_SPARKLE, () => openAiModal(chunkData.id));
                const editBtn = createActionButton('edit-chunk-btn', 'Edit Properties', ICON_PENCIL_EDIT, () => openEditChunkModal(chunkData.id));
                const linkBtn = createActionButton('link-chunk-btn', 'Link Chunk', ICON_LINK, () => handleLinkButtonClick(chunkData.id));
                const deleteBtn = createActionButton('delete-chunk-btn', 'Delete Chunk', ICON_DELETE, () => deleteChunk(chunkData.id));

                actionsContainer.appendChild(aiBtn);
                actionsContainer.appendChild(editBtn);
                actionsContainer.appendChild(linkBtn);
                actionsContainer.appendChild(deleteBtn);

                header.appendChild(headerTitle);
                header.appendChild(actionsContainer);

                const content = document.createElement('div');
                content.className = 'chunk-content';
                content.contentEditable = true;
                content.innerHTML = chunkData.text;
                content.addEventListener('input', () => {
                    state.chunksMap.get(chunkDiv.id).text = content.innerHTML;
                    triggerAutoSave();
                });
                content.addEventListener('focus', () => {
                    chunkDiv.style.zIndex = String(++state.highestZIndex);
                    state.chunksMap.get(chunkDiv.id).zIndex = state.highestZIndex;
                    if (!state.linkingMode) selectChunk(chunkData.id);
                });

                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle';

                header.addEventListener('mousedown', onInteractionStart);
                header.addEventListener('touchstart', onInteractionStart, {
                    passive: false
                });
                resizeHandle.addEventListener('mousedown', onInteractionStart);
                resizeHandle.addEventListener('touchstart', onInteractionStart, {
                    passive: false
                });

                chunkDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (state.linkingMode) {
                        if (state.linkingSourceChunkId && state.linkingSourceChunkId !== chunkData.id) {
                            completeLink(state.linkingSourceChunkId, chunkData.id);
                        }
                    } else {
                        selectChunk(chunkData.id);
                    }
                });

                chunkDiv.appendChild(header);
                chunkDiv.appendChild(content);
                chunkDiv.appendChild(resizeHandle);
                DOMElements.noteCanvas.appendChild(chunkDiv);

                updateChunkHeaderDisplay(chunkData.id);
                updateSelectedVisuals();

                return chunkDiv;
            }


            function deleteChunk(chunkIdToDelete) {
                showMessage("Confirm Delete", `Are you sure you want to delete this chunk?`, [{
                    text: 'Cancel',
                    class: 'btn-secondary'
                }, {
                    text: 'Delete',
                    class: 'btn-danger',
                    action: () => {
                        const chunkIndex = state.chunks.findIndex(c => c.id === chunkIdToDelete);
                        if (chunkIndex > -1) {
                            state.lastDeletedChunk = JSON.parse(JSON.stringify(state.chunks[chunkIndex]));
                            state.chunks.splice(chunkIndex, 1);
                            state.chunksMap.delete(chunkIdToDelete);
                            DOMElements.undoDeleteBtn.disabled = false;
                        }
                        if (state.selectedChunkId === chunkIdToDelete) deselectAllChunks();
                        if (state.linkingSourceChunkId === chunkIdToDelete) cancelLinkingMode(false);
                        if (state.lastAddedChunkId === chunkIdToDelete) {
                            state.lastAddedChunkId = null;
                            DOMElements.centerLastBtn.disabled = true;
                        }

                        state.chunks.forEach(chunk => {
                            if (chunk.nextChunkId === chunkIdToDelete) chunk.nextChunkId = null;
                        });

                        const chunkElement = document.getElementById(chunkIdToDelete);
                        if (chunkElement) chunkElement.remove();
                        drawConnections();
                        updateChunkCounter();
                        triggerAutoSave();
                    }
                }]);
            }

            // --- Selection & Visual Updates ---
            function selectChunk(chunkId) {
                state.selectedChunkId = chunkId;
                updateSelectedVisuals();
            }

            function deselectAllChunks() {
                if (state.linkingMode) cancelLinkingMode(true);
                state.selectedChunkId = null;
                updateSelectedVisuals();
            }

            function updateChunkCounter() {
                DOMElements.chunkCountDisplay.textContent = `Chunks: ${state.chunks.length}`;
            }

            function updateChunkHeaderDisplay(chunkId) {
                const chunkElement = document.getElementById(chunkId);
                const chunkData = state.chunksMap.get(chunkId);
                if (!chunkElement || !chunkData) return;
                const headerTitle = chunkElement.querySelector('.chunk-header-title');
                if (headerTitle) {
                    const selectedShape = SHAPES.find(s => s.name === chunkData.shapeName) || {};
                    const selectedColor = COLORS.find(c => c.name === chunkData.colorName) || {};
                    headerTitle.innerHTML = `<span class="tag">${chunkData.chunkTypeTag}</span> | <span class="shape-symbol" title="${selectedShape?.name}: ${selectedShape?.meaning}">${selectedShape?.symbol}</span> <span title="${selectedShape?.name}: ${selectedShape?.meaning}">${selectedShape?.meaning?.split(',')[0]}</span> | <span class="color-symbol ${selectedColor?.tailwindClass || ''}" title="${selectedColor?.name}: ${selectedColor?.essence}">${selectedColor?.symbol}</span> <span title="${selectedColor?.name}: ${selectedColor?.essence}">${selectedColor?.essence?.split(',')[0]}</span>`;
                }
            }

            function updateSelectedVisuals() {
                document.querySelectorAll('.chorus-chunk').forEach(el => {
                    const chunkData = state.chunksMap.get(el.id);
                    if (!chunkData) return;

                    el.classList.toggle('selected-chunk', el.id === state.selectedChunkId && !state.linkingMode);
                    el.classList.toggle('linking-source-chunk', el.id === state.linkingSourceChunkId && state.linkingMode);

                    const linkButton = el.querySelector('.link-chunk-btn');
                    if (linkButton) {
                        if (el.id === state.linkingSourceChunkId && state.linkingMode) {
                            linkButton.innerHTML = ICON_LINKING_ACTIVE;
                            linkButton.title = 'Cancel Linking';
                            linkButton.classList.add('linking-active');
                        } else if (chunkData.nextChunkId) {
                            linkButton.innerHTML = ICON_UNLINK;
                            linkButton.title = 'Unlink Chunk';
                            linkButton.classList.remove('linking-active');
                        } else {
                            linkButton.innerHTML = ICON_LINK;
                            linkButton.title = 'Link to Next Chunk';
                            linkButton.classList.remove('linking-active');
                        }
                    }
                });
            }

            // --- Linking ---
            function handleLinkButtonClick(chunkId) {
                const chunkData = state.chunksMap.get(chunkId);
                if (!chunkData) return;
                if (state.linkingMode && state.linkingSourceChunkId === chunkId) {
                    cancelLinkingMode(false);
                } else if (chunkData.nextChunkId) {
                    showMessage("Unlink Chunk", `Do you want to remove the link from this chunk?`, [{
                        text: 'Cancel',
                        class: 'btn-secondary'
                    }, {
                        text: 'Unlink',
                        class: 'btn-primary',
                        action: () => {
                            chunkData.nextChunkId = null;
                            drawConnections();
                            updateSelectedVisuals();
                            triggerAutoSave();
                        }
                    }]);
                } else {
                    startLinkingMode(chunkId);
                }
            }

            function startLinkingMode(sourceId) {
                state.linkingMode = true;
                state.linkingSourceChunkId = sourceId;
                DOMElements.body.classList.add('linking-mode');
                selectChunk(sourceId);
            }

            function cancelLinkingMode(isDeselect = false) {
                state.linkingMode = false;
                const prevSourceId = state.linkingSourceChunkId;
                state.linkingSourceChunkId = null;
                DOMElements.body.classList.remove('linking-mode');
                if (isDeselect) state.selectedChunkId = null;
                else if (prevSourceId) selectChunk(prevSourceId);
                updateSelectedVisuals();
            }

            function completeLink(sourceId, targetId) {
                const sourceChunk = state.chunksMap.get(sourceId);
                if (sourceChunk) sourceChunk.nextChunkId = targetId;
                cancelLinkingMode(false);
                drawConnections();
                selectChunk(sourceId);
                triggerAutoSave();
            }

            // --- Drawing Connections ---
            function getIntersectionPointWithRect(rect, internalPoint, externalPoint) {
                const dx = externalPoint.x - internalPoint.x;
                const dy = externalPoint.y - internalPoint.y;
                const p = [-dx, dx, -dy, dy];
                const q = [internalPoint.x - rect.x, rect.x + rect.width - internalPoint.x, internalPoint.y - rect.y, rect.y + rect.height - internalPoint.y];
                let u1 = -Infinity,
                    u2 = Infinity;
                for (let i = 0; i < 4; i++) {
                    if (p[i] === 0) {
                        if (q[i] < 0) return null;
                    } else {
                        const t = q[i] / p[i];
                        if (p[i] < 0 && u1 < t) u1 = t;
                        else if (p[i] > 0 && u2 > t) u2 = t;
                    }
                }
                if (u1 > u2 || u1 > 1 || u1 < 0) {
                    if (u2 > 1 || u2 < 0) return null;
                    return {
                        x: internalPoint.x + u2 * dx,
                        y: internalPoint.y + u2 * dy
                    };
                }
                return {
                    x: internalPoint.x + u1 * dx,
                    y: internalPoint.y + u2 * dy
                };
            }

            let svgDefsCreated = false;

            function drawConnections() {
                if (!svgDefsCreated) {
                    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                    marker.setAttribute('id', 'arrowhead');
                    marker.setAttribute('viewBox', '0 0 10 10');
                    marker.setAttribute('refX', '10');
                    marker.setAttribute('refY', '5');
                    marker.setAttribute('markerUnits', 'strokeWidth');
                    marker.setAttribute('markerWidth', '6');
                    marker.setAttribute('markerHeight', '5');
                    marker.setAttribute('orient', 'auto');
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
                    path.classList.add('arrow-head');
                    marker.appendChild(path);
                    defs.appendChild(marker);
                    DOMElements.svgCanvas.appendChild(defs);
                    svgDefsCreated = true;
                }

                DOMElements.svgCanvas.querySelectorAll('line').forEach(line => line.remove());

                state.chunks.forEach(sourceChunkData => {
                    if (sourceChunkData.nextChunkId) {
                        const targetChunkData = state.chunksMap.get(sourceChunkData.nextChunkId);
                        if (targetChunkData) {
                            const sourceRect = {
                                x: sourceChunkData.x,
                                y: sourceChunkData.y,
                                width: sourceChunkData.width,
                                height: sourceChunkData.height
                            };
                            const targetRect = {
                                x: targetChunkData.x,
                                y: targetChunkData.y,
                                width: targetChunkData.width,
                                height: targetChunkData.height
                            };
                            const sourceCenter = {
                                x: sourceRect.x + sourceRect.width / 2,
                                y: sourceRect.y + sourceRect.height / 2
                            };
                            const targetCenter = {
                                x: targetRect.x + targetRect.width / 2,
                                y: targetRect.y + targetRect.height / 2
                            };

                            const startPoint = getIntersectionPointWithRect(sourceRect, sourceCenter, targetCenter) || sourceCenter;
                            const endPoint = getIntersectionPointWithRect(targetRect, targetCenter, sourceCenter) || targetCenter;

                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', String(startPoint.x));
                            line.setAttribute('y1', String(startPoint.y));
                            line.setAttribute('x2', String(endPoint.x));
                            line.setAttribute('y2', String(endPoint.y));
                            line.classList.add('connecting-line');
                            line.setAttribute('marker-end', 'url(#arrowhead)');
                            DOMElements.svgCanvas.appendChild(line);
                        }
                    }
                });
            }

            // --- Save/Load & Export ---
            function saveDataToFile() {
                state.chunks.forEach(chunkData => {
                    const chunkElement = document.getElementById(chunkData.id);
                    if (chunkElement) {
                        const contentDiv = chunkElement.querySelector('.chunk-content');
                        if (contentDiv) {
                            chunkData.text = contentDiv.innerHTML;
                        }
                    }
                });
                const dataToSave = {
                    chunks: state.chunks,
                    viewport: {
                        scale: state.scale,
                        translateX: state.translateX,
                        translateY: state.translateY
                    }
                };
                downloadFile(JSON.stringify(dataToSave, null, 2), 'chorus-notes.json', 'application/json');
            }

            function downloadFile(content, fileName, contentType) {
                const a = document.createElement('a');
                const file = new Blob([content], {
                    type: contentType
                });
                a.href = URL.createObjectURL(file);
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            }

            function getOrderedChunksForExport() {
                const localChunkMap = new Map(state.chunks.map(chunk => {
                    const newChunk = JSON.parse(JSON.stringify(chunk));
                    const chunkEl = document.getElementById(newChunk.id);
                    if (chunkEl) {
                        const contentDiv = chunkEl.querySelector('.chunk-content');
                        if (contentDiv) newChunk.text = contentDiv.innerHTML;
                    }
                    return [newChunk.id, newChunk];
                }));
                const orderedChunks = [];
                const visited = new Set();
                const inCurrentPath = new Set();

                const allTargetIds = new Set();
                localChunkMap.forEach(chunk => {
                    if (chunk.nextChunkId) allTargetIds.add(chunk.nextChunkId);
                });
                const startNodes = [];
                localChunkMap.forEach(chunk => {
                    if (!allTargetIds.has(chunk.id)) startNodes.push(chunk);
                });
                startNodes.sort((a, b) => a.y === b.y ? a.x - b.x : a.y - b.y);


                function traverse(chunkId) {
                    if (!chunkId || visited.has(chunkId)) return;
                    if (inCurrentPath.has(chunkId)) {
                        console.warn("Cycle detected involving chunk:", chunkId, ". Breaking traversal for this path.");
                        return;
                    }

                    visited.add(chunkId);
                    inCurrentPath.add(chunkId);
                    const chunk = localChunkMap.get(chunkId);
                    if (chunk) {
                        orderedChunks.push(chunk);
                        if (chunk.nextChunkId) {
                            traverse(chunk.nextChunkId);
                        }
                    }
                    inCurrentPath.delete(chunkId);
                }

                startNodes.forEach(startNode => traverse(startNode.id));

                const orphanedChunks = [];
                localChunkMap.forEach(chunk => {
                    if (!visited.has(chunk.id)) orphanedChunks.push(chunk);
                });
                orphanedChunks.sort((a, b) => {
                    if (a.y !== b.y) return a.y - b.y;
                    return a.x - b.x;
                });
                orderedChunks.push(...orphanedChunks);
                return orderedChunks;
            }

            function getCombinedText() {
                const exportOrderChunks = getOrderedChunksForExport();
                return exportOrderChunks.map(chunk => {
                    let linkInfo = "";
                    if (chunk.nextChunkId) {
                        const targetChunkData = state.chunksMap.get(chunk.nextChunkId);
                        if (targetChunkData) {
                            linkInfo = `\n  -> Links to: ${targetChunkData.chunkTypeTag}`;
                        }
                    }
                    const shape = SHAPES.find(s => s.name === chunk.shapeName) || {};
                    const color = COLORS.find(c => c.name === chunk.colorName) || {};
                    const header = `${chunk.chunkTypeTag} | ${shape.symbol} ${shape.meaning?.split(',')[0]} | ${color.symbol} ${color.essence?.split(',')[0]}`;
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = chunk.text;
                    const plainText = tempDiv.textContent || tempDiv.innerText || "";
                    return `${header}\n${plainText}${linkInfo}\n\n---\n`;
                }).join('');
            }

            // --- Interaction Logic (Pan, Zoom, Drag, Resize) ---
            const getPointerCoordinates = e => e.touches ? ({
                x: e.touches[0].clientX,
                y: e.touches[0].clientY,
                count: e.touches.length
            }) : ({
                x: e.clientX,
                y: e.clientY,
                count: e.buttons === 1 ? 1 : 0
            });

            function getPinchDistance(e) {
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                return Math.sqrt(Math.pow(t1.clientX - t2.clientX, 2) + Math.pow(t1.clientY - t2.clientY, 2));
            }

            function onInteractionStart(e) {
                if (e.touches && e.touches.length > 1) {
                    e.preventDefault();
                    state.currentAction = 'pinch';
                    state.initialPinchDistance = getPinchDistance(e);
                    return;
                }

                const pointer = getPointerCoordinates(e);
                let targetElement = e.target;
                let actionTarget = null;

                if (targetElement.classList.contains('resize-handle')) actionTarget = 'resize';
                else if (targetElement.closest('.chunk-header') && !targetElement.closest('.chunk-action-btn')) actionTarget = 'drag';
                else if (targetElement === DOMElements.noteCanvasContainer || targetElement === DOMElements.transformContainer || targetElement === DOMElements.noteCanvas) actionTarget = 'pan';

                if (actionTarget === 'pan') {
                    if (state.linkingMode) {
                        deselectAllChunks();
                        return;
                    }
                    state.currentAction = 'pan';
                    state.panStartX = pointer.x - state.translateX;
                    state.panStartY = pointer.y - state.translateY;
                    DOMElements.noteCanvasContainer.classList.add('panning');
                } else if (actionTarget === 'drag' || actionTarget === 'resize') {
                    const chunkEl = targetElement.closest('.chorus-chunk');
                    if (!chunkEl) return;
                    selectChunk(chunkEl.id);
                    chunkEl.style.zIndex = String(++state.highestZIndex);
                    state.chunksMap.get(chunkEl.id).zIndex = state.highestZIndex;

                    if (actionTarget === 'resize') {
                        state.currentAction = 'resize';
                        state.interactionStartX = pointer.x;
                        state.interactionStartY = pointer.y;
                        state.startWidth = chunkEl.offsetWidth;
                        state.startHeight = chunkEl.offsetHeight;
                    } else { // drag
                        state.currentAction = 'drag';
                        const worldPointer = screenToWorld(pointer.x, pointer.y);
                        state.offsetX = worldPointer.x - chunkEl.offsetLeft;
                        state.offsetY = worldPointer.y - chunkEl.offsetTop;
                    }
                } else {
                    return;
                }

                document.addEventListener('mousemove', onInteractionMove);
                document.addEventListener('mouseup', onInteractionEnd);
                document.addEventListener('touchmove', onInteractionMove, {
                    passive: false
                });
                document.addEventListener('touchend', onInteractionEnd);
            }

            function onInteractionMove(e) {
                if (!state.currentAction) return;
                e.preventDefault();

                if (state.currentAction === 'pinch' && e.touches.length === 2) {
                    const newPinchDistance = getPinchDistance(e);
                    const scaleFactor = newPinchDistance / state.initialPinchDistance;
                    state.initialPinchDistance = newPinchDistance;

                    const rect = DOMElements.noteCanvasContainer.getBoundingClientRect();
                    const t1 = e.touches[0];
                    const t2 = e.touches[1];
                    const centerX = (t1.clientX + t2.clientX) / 2 - rect.left;
                    const centerY = (t1.clientY + t2.clientY) / 2 - rect.top;

                    const worldX = (centerX - state.translateX) / state.scale;
                    const worldY = (centerY - state.translateY) / state.scale;

                    const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, state.scale * scaleFactor));
                    state.translateX = centerX - worldX * newScale;
                    state.translateY = centerY - worldY * newScale;
                    state.scale = newScale;

                    applyTransform();
                    return;
                }

                const pointer = getPointerCoordinates(e);

                requestAnimationFrame(() => {
                    if (state.currentAction === 'pan') {
                        state.translateX = pointer.x - state.panStartX;
                        state.translateY = pointer.y - state.panStartY;
                        applyTransform();
                    } else if (state.currentAction === 'drag') {
                        const chunkEl = document.getElementById(state.selectedChunkId);
                        const chunkData = state.chunksMap.get(state.selectedChunkId);
                        if (!chunkEl || !chunkData) return;
                        const worldPointer = screenToWorld(pointer.x, pointer.y);

                        chunkData.x = Math.max(0, worldPointer.x - state.offsetX);
                        chunkData.y = Math.max(0, worldPointer.y - state.offsetY);

                        chunkEl.style.left = `${chunkData.x}px`;
                        chunkEl.style.top = `${chunkData.y}px`;
                        drawConnections();
                    } else if (state.currentAction === 'resize') {
                        const chunkEl = document.getElementById(state.selectedChunkId);
                        const chunkData = state.chunksMap.get(state.selectedChunkId);
                        if (!chunkEl || !chunkData) return;
                        const deltaX = (pointer.x - state.interactionStartX) / state.scale;
                        const deltaY = (pointer.y - state.interactionStartY) / state.scale;

                        chunkData.width = Math.max(200, state.startWidth + deltaX);
                        chunkData.height = Math.max(100, state.startHeight + deltaY);

                        chunkEl.style.width = `${chunkData.width}px`;
                        chunkEl.style.height = `${chunkData.height}px`;
                        drawConnections();
                    }
                });
            }

            function onInteractionEnd(e) {
                let stateChanged = false;
                if (state.currentAction === 'pinch' && e.touches.length < 2) {
                    state.currentAction = null;
                    state.initialPinchDistance = null;
                    stateChanged = true;
                } else if (state.currentAction === 'drag' || state.currentAction === 'resize') {
                    const chunkEl = document.getElementById(state.selectedChunkId);
                    const chunkData = state.chunksMap.get(state.selectedChunkId);
                    if (chunkEl && chunkData) {
                        chunkData.x = chunkEl.offsetLeft;
                        chunkData.y = chunkEl.offsetTop;
                        chunkData.width = chunkEl.offsetWidth;
                        chunkData.height = chunkEl.offsetHeight;
                        stateChanged = true;
                    }
                } else if (state.currentAction === 'pan') {
                    DOMElements.noteCanvasContainer.classList.remove('panning');
                    stateChanged = true;
                }

                if (stateChanged) {
                    triggerAutoSave();
                }

                if (!e.touches || e.touches.length === 0) {
                    state.currentAction = null;
                    document.removeEventListener('mousemove', onInteractionMove);
                    document.removeEventListener('mouseup', onInteractionEnd);
                    document.removeEventListener('touchmove', onInteractionMove);
                    document.removeEventListener('touchend', onInteractionEnd);
                }
            }

            // --- Event Listeners Setup ---
            function setupEventListeners() {
                // Browser close warning
                window.addEventListener('beforeunload', (e) => {
                    // This is now handled by auto-save, but we can keep it as a safety net
                    // for unsaved file downloads, though not strictly necessary.
                    if (state.chunks.length > 0) {
                         e.preventDefault();
                         e.returnValue = '';
                    }
                });

                // Main canvas interactions
                DOMElements.noteCanvasContainer.addEventListener('mousedown', onInteractionStart);
                DOMElements.noteCanvasContainer.addEventListener('touchstart', onInteractionStart, {
                    passive: false
                });
                DOMElements.noteCanvasContainer.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const rect = DOMElements.noteCanvasContainer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    const worldXBeforeZoom = (mouseX - state.translateX) / state.scale;
                    const worldYBeforeZoom = (mouseY - state.translateY) / state.scale;

                    const delta = e.deltaY * ZOOM_SENSITIVITY * -1;
                    const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, state.scale * (1 + delta)));

                    state.translateX = mouseX - worldXBeforeZoom * newScale;
                    state.translateY = mouseY - worldYBeforeZoom * newScale;
                    state.scale = newScale;

                    applyTransform();
                    triggerAutoSave();
                }, {
                    passive: false
                });

                // Toolbar buttons
                DOMElements.addChunkBtn.addEventListener('click', () => showModal(DOMElements.addChunkModal));
                DOMElements.centerLastBtn.addEventListener('click', () => {
                    if (state.lastAddedChunkId) centerOnChunk(state.lastAddedChunkId);
                });
                DOMElements.shuffleChunksBtn.addEventListener('click', shuffleChunks);
                DOMElements.summarizeBtn.addEventListener('click', summarizeBoard);
                DOMElements.clearCanvasBtn.addEventListener('click', () => {
                    if (state.chunks.length === 0) {
                        showMessage("Canvas Empty", "The canvas is already clear.");
                        return;
                    }
                    showMessage("Confirm Clear", "Are you sure you want to clear the entire canvas? This action cannot be undone.", [{
                        text: 'Cancel',
                        class: 'btn-secondary'
                    }, {
                        text: 'Clear Canvas',
                        class: 'btn-danger',
                        action: () => {
                            state.lastDeletedChunk = null; // Clearing canvas invalidates undo
                            renderBoard([]);
                            clearAutoSave(); // Explicitly clear save data
                            showMessage("Canvas Cleared", "All notes and links have been removed.");
                        }
                    }]);
                });
                
                DOMElements.undoDeleteBtn.addEventListener('click', () => {
                    if (state.lastDeletedChunk) {
                        const chunkData = state.lastDeletedChunk;
                        state.chunks.push(chunkData);
                        state.chunksMap.set(chunkData.id, chunkData);
                        createChunkElement(chunkData);

                        if (chunkData.zIndex > state.highestZIndex) {
                             state.highestZIndex = chunkData.zIndex;
                        }
                        drawConnections();
                        updateChunkCounter();
                        triggerAutoSave();

                        state.lastDeletedChunk = null;
                        DOMElements.undoDeleteBtn.disabled = true;
                    }
                });

                const zoom = (factor) => {
                    const rect = DOMElements.noteCanvasContainer.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;

                    const worldXBeforeZoom = (centerX - state.translateX) / state.scale;
                    const worldYBeforeZoom = (centerY - state.translateY) / state.scale;

                    const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, state.scale * factor));

                    state.translateX = centerX - worldXBeforeZoom * newScale;
                    state.translateY = centerY - worldYBeforeZoom * newScale;
                    state.scale = newScale;

                    applyTransform();
                    triggerAutoSave();
                };

                DOMElements.zoomInBtn.addEventListener('click', () => zoom(1.25));
                DOMElements.zoomOutBtn.addEventListener('click', () => zoom(0.8));
                DOMElements.zoomResetBtn.addEventListener('click', resetAndCenterView);

                // Save & Load Listeners
                DOMElements.saveBtn.addEventListener('click', saveDataToFile);
                DOMElements.loadBtn.addEventListener('click', () => DOMElements.fileLoadInput.click());
                DOMElements.fileLoadInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const loadedData = JSON.parse(e.target.result);
                            if (loadedData && Array.isArray(loadedData.chunks)) {
                                renderBoard(loadedData.chunks); // This now triggers auto-save
                                if (loadedData.viewport) {
                                    state.scale = loadedData.viewport.scale || 1;
                                    state.translateX = loadedData.viewport.translateX || 0;
                                    state.translateY = loadedData.viewport.translateY || 0;
                                    applyTransform();
                                    triggerAutoSave();
                                }
                            }
                        } catch (error) {
                            showMessage("Load Error", `Could not parse file: ${error.message}`);
                        }
                    };
                    reader.readAsText(file);
                    event.target.value = null;
                });

                // Export Listeners
                DOMElements.exportBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const dropdown = DOMElements.exportDropdown;
                    dropdown.classList.toggle('hidden');
                });
                document.addEventListener('click', (e) => {
                    if (!DOMElements.exportBtn.contains(e.target) && !DOMElements.exportDropdown.contains(e.target)) {
                        DOMElements.exportDropdown.classList.add('hidden');
                    }
                });
                DOMElements.exportTxtBtn.addEventListener('click', () => {
                    if (state.chunks.length === 0) {
                        showMessage("Empty Board", "Nothing to export.");
                        return;
                    }
                    const text = getCombinedText();
                    downloadFile(text, 'chorus-notes.txt', 'text/plain');
                    DOMElements.exportDropdown.classList.add('hidden');
                });
                DOMElements.exportHtmlBtn.addEventListener('click', () => {
                    if (state.chunks.length === 0) {
                        showMessage("Empty Board", "Nothing to export.");
                        return;
                    }
                    const exportOrderChunks = getOrderedChunksForExport();
                    let htmlContent = `<html><head><title>CHORUS Notes</title><style>body{font-family:sans-serif; line-height:1.6;} .chunk{border:1px solid #eee; margin-bottom:20px; padding:15px; border-radius:5px; box-shadow: 2px 2px 5px #ccc;} h3{margin-top:0; font-size:1.1em; color:#333; border-bottom:1px solid #eee; padding-bottom:5px;} .chunk-meta{font-size:0.9em; color:#777;} .chunk-meta span[title]{cursor:help; border-bottom: 1px dotted #777;} .link-info{font-style:italic; color:#555; font-size:0.85em;}</style></head><body><h1>CHORUS Notes</h1>`;
                    exportOrderChunks.forEach(chunk => {
                        const shape = SHAPES.find(s => s.name === chunk.shapeName) || {};
                        const color = COLORS.find(c => c.name === chunk.colorName) || {};
                        const shapeHtml = `<span title="${shape.name}: ${shape.meaning}">${shape.symbol} ${shape.meaning?.split(',')[0]}</span>`;
                        const colorHtml = `<span title="${color.name}: ${color.essence}">${color.symbol} ${color.essence?.split(',')[0]}</span>`;
                        const headerMeta = `${chunk.chunkTypeTag} &bull; ${shapeHtml} &bull; ${colorHtml}`;
                        let linkInfoHtml = "";
                        if (chunk.nextChunkId) {
                            const targetChunkData = state.chunksMap.get(chunk.nextChunkId);
                            if (targetChunkData) {
                                linkInfoHtml = `<div class="link-info">Links to: ${targetChunkData.chunkTypeTag}</div>`;
                            }
                        }
                        htmlContent += `<div class="chunk"><h3>${chunk.chunkTypeTag}</h3><div class="chunk-meta">${headerMeta}</div><div>${chunk.text}</div>${linkInfoHtml}</div>`;
                    });
                    htmlContent += '</body></html>';
                    downloadFile(htmlContent, 'chorus-notes.html', 'text/html');
                    DOMElements.exportDropdown.classList.add('hidden');
                });
                DOMElements.exportMdBtn.addEventListener('click', () => {
                    if (state.chunks.length === 0) {
                        showMessage("Empty Board", "Nothing to export.");
                        return;
                    }
                    const exportOrderChunks = getOrderedChunksForExport();
                    let mdContent = '# CHORUS Notes\n\n';
                    exportOrderChunks.forEach(chunk => {
                        const shape = SHAPES.find(s => s.name === chunk.shapeName) || {};
                        const color = COLORS.find(c => c.name === chunk.colorName) || {};
                        const headerMeta = `${chunk.chunkTypeTag} â€¢ ${shape.symbol} ${shape.meaning?.split(',')[0]} â€¢ ${color.symbol} ${color.essence?.split(',')[0]}`;

                        let textContent = chunk.text;
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = textContent;
                        tempDiv.querySelectorAll('p').forEach(p => {
                            p.insertAdjacentText('afterend', '\n\n');
                            p.replaceWith(...p.childNodes);
                        });
                        tempDiv.querySelectorAll('br').forEach(br => br.replaceWith('\n'));
                        tempDiv.querySelectorAll('strong, b').forEach(s => s.replaceWith(`**${s.textContent}**`));
                        tempDiv.querySelectorAll('em, i').forEach(e => e.replaceWith(`*${e.textContent}*`));
                        tempDiv.querySelectorAll('a').forEach(a => a.replaceWith(`[${a.textContent}](${a.href})`));
                        textContent = (tempDiv.textContent || tempDiv.innerText || "").trim();

                        mdContent += `## ${chunk.chunkTypeTag}\n`;
                        mdContent += `*Metadata: ${headerMeta}*\n\n`;
                        mdContent += `${textContent}\n`;

                        if (chunk.nextChunkId) {
                            const targetChunkData = state.chunksMap.get(chunk.nextChunkId);
                            if (targetChunkData) {
                                mdContent += `\n  *â†’ Links to: ${targetChunkData.chunkTypeTag}*\n`;
                            }
                        }
                        mdContent += `\n---\n\n`;
                    });
                    downloadFile(mdContent, 'chorus-notes.md', 'text/markdown');
                    DOMElements.exportDropdown.classList.add('hidden');
                });


                // Settings, Help, Donate
                DOMElements.settingsBtn.addEventListener('click', () => {
                    originalTheme = DOMElements.themeSelect.value;
                    showModal(DOMElements.settingsModal)
                });
                DOMElements.saveSettingsBtn.addEventListener('click', saveSettings);
                DOMElements.cancelSettingsBtn.addEventListener('click', cancelSettings);
                DOMElements.closeSettingsModalBtn.addEventListener('click', cancelSettings);
                DOMElements.themeSelect.addEventListener('change', (e) => {
                    applyTheme(e.target.value);
                });

                DOMElements.helpBtn.addEventListener('click', () => showModal(DOMElements.helpModal));
                DOMElements.donateBtn.addEventListener('click', () => {
                    showMessage(
                        "Support CHORUS",
                        `Thank you for considering a donation! This project is developed and maintained by an independent creator. Your support helps keep the app free and growing.<br><br>You can support the project here: <a href="https://ko-fi.com/thorstenbecker" target="_blank" class="text-[var(--color-primary)] hover:underline">Ko-fi.com/thorstenbecker</a>`,
                        [{
                            text: 'OK',
                            class: 'btn-primary'
                        }]
                    );
                });

                // Modals
                DOMElements.confirmAddChunkBtn.addEventListener('click', () => {
                    const type = ALL_CHUNK_TYPES.find(ct => ct.tag === DOMElements.chunkTypeSelect.value);
                    const shape = SHAPES.find(s => s.name === DOMElements.chunkShapeSelect.value);
                    const color = COLORS.find(c => c.name === DOMElements.chunkColorSelect.value);
                    if (type && shape && color) {
                        addChunkToCanvas({
                            type,
                            shape,
                            color
                        });
                        hideModal(DOMElements.addChunkModal);
                    }
                });
                DOMElements.confirmEditChunkBtn.addEventListener('click', () => {
                    const chunkId = DOMElements.editingChunkIdInput.value;
                    const chunkData = state.chunksMap.get(chunkId);

                    if (chunkData) {
                        chunkData.chunkTypeTag = DOMElements.editChunkTypeSelect.value;
                        chunkData.shapeName = DOMElements.editChunkShapeSelect.value;
                        chunkData.colorName = DOMElements.editChunkColorSelect.value;

                        updateChunkHeaderDisplay(chunkId);
                        hideModal(DOMElements.editChunkModal);
                        triggerAutoSave();
                    } else {
                        showMessage("Error", "Could not find the chunk to update.");
                    }
                });
                [DOMElements.cancelAddChunkBtn, DOMElements.cancelEditChunkBtn, DOMElements.closeHelpModalSpan, DOMElements.closeHelpBtn].forEach(el => el.addEventListener('click', () => hideModal(el.closest('.modal'))));
                
                // Session Restore Modal Listeners
                DOMElements.continueSessionBtn.addEventListener('click', () => {
                    hideModal(DOMElements.sessionRestoreModal);
                    renderBoard(state.chunks);
                    applyTransform();
                });

                DOMElements.startFreshBtn.addEventListener('click', () => {
                    hideModal(DOMElements.sessionRestoreModal);
                    clearAutoSave();
                    state.chunks = []; // Reset state
                    state.lastDeletedChunk = null;
                    state.lastAddedChunkId = null;
                    renderBoard([]);
                    resetAndCenterView();
                });


                // Keyboard Shortcuts
                document.addEventListener('keydown', (e) => {
                    const activeEl = document.activeElement;
                    const isInputFocused = activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable;

                    // Handle undo/redo globally
                    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
                        if(!isInputFocused){ // Prevent interfering with browser's text undo
                           e.preventDefault();
                           DOMElements.undoDeleteBtn.click();
                        }
                    }

                    if (!DOMElements.body.querySelector('.modal:not(.hidden)')) {
                        if (!isInputFocused) {
                            let handled = true;
                            switch (e.key.toLowerCase()) {
                                case 'a':
                                    DOMElements.addChunkBtn.click();
                                    break;
                                case 'c':
                                    DOMElements.centerLastBtn.click();
                                    break;
                                case 'delete':
                                case 'backspace':
                                    if (state.selectedChunkId) deleteChunk(state.selectedChunkId);
                                    break;
                                case 'escape':
                                    deselectAllChunks();
                                    break;
                                case '+':
                                case '=':
                                    DOMElements.zoomInBtn.click();
                                    break;
                                case '-':
                                    DOMElements.zoomOutBtn.click();
                                    break;
                                case '0':
                                    DOMElements.zoomResetBtn.click();
                                    break;
                                default:
                                    handled = false;
                            }
                            if (handled) e.preventDefault();
                        }
                    }
                });
            }

            function populateSelectWithOptions(selectElement, optionsArray, currentValue, groups = null, groupLabelFormatterFn = null) {
                selectElement.innerHTML = '';
                if (groups && groupLabelFormatterFn) {
                    for (const groupKey in groups) {
                        if (groups.hasOwnProperty(groupKey)) {
                            const groupItems = groups[groupKey];
                            const optgroup = document.createElement('optgroup');
                            optgroup.label = groupLabelFormatterFn(groupKey);
                            groupItems.forEach(item => {
                                const option = document.createElement('option');
                                option.value = item.tag;
                                option.textContent = `${item.tag} - ${item.description}`;
                                if (item.tag === currentValue) option.selected = true;
                                optgroup.appendChild(option);
                            });
                            selectElement.appendChild(optgroup);
                        }
                    }
                } else if (optionsArray) {
                    optionsArray.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.value;
                        option.textContent = opt.text;
                        if (opt.value === currentValue) option.selected = true;
                        selectElement.appendChild(option);
                    });
                }
            }

            function populateAddChunkModal() {
                const formatGroupLabel = (key) => key.charAt(0).toUpperCase() + key.slice(1) + " Chunks";
                populateSelectWithOptions(DOMElements.chunkTypeSelect, null, null, CHUNK_TYPES, formatGroupLabel);
                populateSelectWithOptions(DOMElements.chunkShapeSelect, SHAPES.map(s => ({
                    value: s.name,
                    text: `${s.symbol} ${s.name} - ${s.meaning}`
                })), SHAPES[0].name);
                populateSelectWithOptions(DOMElements.chunkColorSelect, COLORS.map(c => ({
                    value: c.name,
                    text: `${c.symbol} ${c.name} - ${c.essence}`
                })), COLORS[0].name);
            }

            function populateHelpModal() {
                DOMElements.helpContent.innerHTML = `
                <h3>What is CHORUS?</h3>
                <p>You can read about the <a href="https://drive.google.com/file/d/1qXp0-kV4HUEdkB1A_epyTnopkdUdl3rY/view?usp=sharing" target="_blank" class="text-[var(--color-primary)] hover:underline">full concept of CHORUS here</a>.</p>
                <p>CHORUS is a system for those who think in constellations, not straight lines. It offers structure without rigidity and clarity without collapse. Itâ€™s a modular, visual, and non-linear method for organizing notes and a way of navigating your own cognition.</p>
                <p>Built from chunks, not outlines, it uses shape and color for emotional and structural resonance. It honors how you think, not how youâ€™re told to write.</p>
                
                <h3>âœ¨ NEW: Auto-Save & Session Restore</h3>
                <p>Your work is now <b>automatically saved</b> to your browser's local storage. When you return, a prompt will ask if you want to continue your last session or start fresh. Clearing the canvas or starting fresh will also clear this saved data.</p>

                <h3>Settings & AI Features</h3>
                <p>Click the gear icon (<b>Settings</b>) to configure the app. This app also includes AI features powered by Google's Gemini model to supercharge your workflow.</p>
                <ul>
                    <li><b>Theme:</b> Choose from several color schemes (Sepia, Dark, Ballpoint, Typewriter, Poetry) to suit your preference.</li>
                    <li><b>View Options:</b> Toggle the visibility of the background grid and the central North Star marker for a cleaner or more guided workspace.</li>
                    <li><b>API Key:</b> You must provide your own Google AI API key to use the AI features. Your key is saved locally in your browser and never sent anywhere except to the Google API.</li>
                    <li><b>AI Assistant:</b> Click the 'sparkle' icon âœ¨ in a chunk's header to open the AI Assistant. Use it to generate text, rewrite content, brainstorm ideas, and more.</li>
                    <li><b>Summarize Board:</b> Click the 'Summarize' button in the top toolbar to get a high-level summary of all notes on your canvas.</li>
                </ul>

                <h3>Saving, Loading & Exporting</h3>
                <p>Use <code>Save</code> to download a JSON file of your project as a permanent backup. Use <code>Load</code> to open a previously saved file.</p>
                <p>The <code>Export</code> button lets you save your work in different formats for use in other applications:
                    <ul>
                        <li><b>TXT:</b> A plain text file with all chunk content in order.</li>
                        <li><b>HTML:</b> A simple, self-contained web page of your notes.</li>
                        <li><b>MD:</b> A Markdown file suitable for apps like Obsidian or Logseq.</li>
                    </ul>
                </p>

                <h3>Keyboard Shortcuts</h3>
                <p>
                    <code>A</code>: Add Chunk | <code>C</code>: Center on Last | <code>Esc</code>: Close modals, cancel linking, or deselect chunks. <br>
                    <code>Del</code>/<code>Backspace</code>: Delete Selected | <code>+/-</code>/<code>=</code>: Zoom | <code>0</code>: Reset Zoom<br>
                    <code>Ctrl/Cmd + S</code>: Save | <code>Ctrl/Cmd + O</code>: Load | <code>Ctrl/Cmd + Z</code>: Undo Delete
                </p>

                <h3>Core Chunk Types</h3>
                <ul>${CHUNK_TYPES.core.map(c => `<li><b>${c.tag}:</b> ${c.description}</li>`).join('')}</ul>
                <h3>Optional Chunk Types</h3>
                <ul>${CHUNK_TYPES.optional.map(c => `<li><b>${c.tag}:</b> ${c.description}</li>`).join('')}</ul>
                <h3>Narrative Extensions</h3>
                <ul>${CHUNK_TYPES.narrative.map(c => `<li><b>${c.tag}:</b> ${c.description}</li>`).join('')}</ul>
                <h3>Conceptual Add-ons</h3>
                <ul>${CHUNK_TYPES.conceptual.map(c => `<li><b>${c.tag}:</b> ${c.description}</li>`).join('')}</ul>

                <h3>Shapes</h3>
                <ul>${SHAPES.map(s => `<li><b>${s.symbol} ${s.name}:</b> ${s.meaning}</li>`).join('')}</ul>
                
                <h3>Color Tags</h3>
                <ul>${COLORS.map(c => `<li><b>${c.symbol} ${c.name}:</b> ${c.essence}</li>`).join('')}</ul>

                <h3>Usage, Licensing & Support</h3>
                <p><strong>Free for Individual Creators:</strong><br>
                CHORUS is free for individual writers, students, researchers, and creatives to use for personal, academic, and professional work (e.g., writing a book, planning an essay, organizing research notes). If you find the tool helps your creative practice, please consider supporting its future development with a donation.</p>
                
                <p class="mt-4"><strong>License Required for Organizational Use:</strong><br>
                A license is required for use within a company, team, or formal organization. This includes, but is not limited to:
                <ul>
                    <li>- Use in a corporate or studio writing room.</li>
                    <li>- Mandated use for a team of employees or contractors.</li>
                    <li>- Integration into a commercial service or educational curriculum.</li>
                </ul>
                This policy ensures the tool remains accessible to individual creators while valuing its role in structured, collaborative environments. For all licensing inquiries, please reach out to <b>hello@thorstenbecker.de</b>.
                </p>
            `;
            }

            function shuffleChunks() {
                if (state.chunks.length < 2) {
                    showMessage("Not Enough Chunks", "You need at least two chunks on the canvas to shuffle.");
                    return;
                }
                const PADDING = 50;
                let minX = Infinity,
                    minY = Infinity,
                    maxX = -Infinity,
                    maxY = -Infinity;

                state.chunks.forEach(chunk => {
                    minX = Math.min(minX, chunk.x);
                    minY = Math.min(minY, chunk.y);
                    maxX = Math.max(maxX, chunk.x + chunk.width);
                    maxY = Math.max(maxY, chunk.y + chunk.height);
                });

                const bboxWidth = maxX - minX;
                const bboxHeight = maxY - minY;

                state.chunks.forEach(chunkData => {
                    const chunkEl = document.getElementById(chunkData.id);
                    if (chunkEl) {
                        chunkData.x = minX + Math.random() * (bboxWidth - chunkData.width);
                        chunkData.y = minY + Math.random() * (bboxHeight - chunkData.height);
                        chunkEl.style.left = chunkData.x + 'px';
                        chunkEl.style.top = chunkData.y + 'px';
                    }
                });
                drawConnections();
                triggerAutoSave();
            }

            async function summarizeBoard() {
                if (!state.geminiApiKey) {
                    showMessage("API Key Required", "Please set your Google AI API key in the Settings menu to use this feature.");
                    return;
                }
                if (state.chunks.length === 0) {
                    showMessage("Empty Canvas", "There is nothing to summarize. Add some chunks first.");
                    return;
                }

                showMessage("AI Summarization", "The AI is reading your notes and generating a summary. This may take a moment...", [{
                    text: 'Working...',
                    class: 'btn-primary',
                    noHide: true
                }]);

                const fullText = getCombinedText();
                const prompt = `Please provide a concise, high-level summary of the following notes from a creative writing project. The notes are organized into chunks with different types. Focus on the core themes, character arcs, and major plot points. The notes are:\n\n---\n\n${fullText}`;

                try {
                    let chatHistory = [{
                        role: "user",
                        parts: [{
                            text: prompt
                        }]
                    }];
                    const payload = {
                        contents: chatHistory
                    };
                    const apiKey = state.geminiApiKey;
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0) {
                        const summaryText = result.candidates[0].content.parts[0].text.replace(/\n/g, '<br>');
                        showMessage("AI Summary", summaryText);
                    } else {
                        throw new Error("No summary was returned from the API.");
                    }

                } catch (error) {
                    showMessage("AI Error", `Could not generate summary: ${error.message}`);
                    console.error(error);
                }
            }

            function openEditChunkModal(chunkId) {
                const chunkData = state.chunksMap.get(chunkId);
                if (!chunkData) return;
                DOMElements.editingChunkIdInput.value = chunkId;

                const formatGroupLabel = (key) => key.charAt(0).toUpperCase() + key.slice(1) + " Chunks";
                populateSelectWithOptions(DOMElements.editChunkTypeSelect, null, chunkData.chunkTypeTag, CHUNK_TYPES, formatGroupLabel);
                populateSelectWithOptions(DOMElements.editChunkShapeSelect, SHAPES.map(s => ({
                    value: s.name,
                    text: `${s.symbol} ${s.name}`
                })), chunkData.shapeName);
                populateSelectWithOptions(DOMElements.editChunkColorSelect, COLORS.map(c => ({
                    value: c.name,
                    text: `${c.symbol} ${c.name}`
                })), chunkData.colorName);

                showModal(DOMElements.editChunkModal);
            }

            function openAiModal(chunkId) {
                state.activeAiChunkId = chunkId;
                showModal(DOMElements.aiActionModal);
            }

            // --- Initialization ---
            function initializeApp() {
                document.getElementById('copyrightYear').textContent = new Date().getFullYear();
                loadSettings();
                populateAddChunkModal();
                populateHelpModal();
                setupEventListeners();

                const wasSessionFound = loadSessionFromAutoSave();

                if (!wasSessionFound) {
                    // If no session, initialize as normal.
                    renderBoard([]);
                    resetAndCenterView();
                }
                // If a session was found, a modal is now visible. We wait for user input.
                // The event listeners for the modal buttons will handle the next steps.

                setTimeout(() => DOMElements.noteCanvasContainer.focus(), 100);
                console.log("CHORUS Writer's App Initialized");
            }

            initializeApp();
        });
    </script>
</body>
</html>
